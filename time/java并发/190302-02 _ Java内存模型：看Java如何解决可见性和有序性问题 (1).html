<head>
    <meta charset="utf-8">
    <meta name="Keywords" content="极客时间,极客邦,极客邦科技,极客邦控股,极客时间App,专栏订阅,极客新闻,二叉树,极客Live,QCon,左耳听风,AI技术内参,大航海时代,陈皓,徐飞,洪亮劼,霍泰稳,池建强,Selina,Gary,InfoQ,极客搜索">
    <meta name="description" content="极客时间是极客邦科技出品的一款 IT 内容知识服务 App，内容包含专栏订阅、极客新闻、热点专题、直播、视频和音频等多形式的知识内容，并设有陈皓专栏、徐飞专栏、洪亮劼专栏等专栏供订阅。">
    <link rel="apple-touch-icon" sizes="180x180" href="//static001.geekbang.org/static/icon/time/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="//static001.geekbang.org/static/icon/time/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="//static001.geekbang.org/static/icon/time/favicon-16x16.png">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no,viewport-fit=cover">
    <meta name="format-detection" content="telephone=no">
    <title>02 | Java内存模型：看Java如何解决可见性和有序性问题</title>

    <link href="https://static001.geekbang.org/static/time/css/app.3e04e644962ca8c2f97ec7731bb7710c.css" rel="stylesheet">
    <style type="text/css">.hljs-ln {
        border-collapse: collapse
    }

    .hljs-ln td {
        padding: 0
    }

    .hljs-ln-n:before {
        content: attr(data-line-number)
    }</style>
    <style type="text/css">#iv-container {
        position: fixed;
        background: #0d0d0d;
        width: 100%;
        height: 100%;
        top: 0;
        left: 0;
        display: none;
        z-index: 1000
    }

    .iv-container {
        overflow: hidden
    }

    .iv-close {
        width: 26px;
        height: 26px;
        position: absolute;
        right: 20px;
        top: 20px;
        cursor: pointer;
        text-align: center;
        overflow: hidden;
        text-shadow: 0 0 3px #6d6d6d;
        -webkit-transition: all .2s ease;
        -moz-transition: all ease .2s;
        -o-transition: all ease .2s;
        transition: all .2s ease
    }

    .iv-close:after, .iv-close:before {
        content: "";
        height: 2px;
        width: 26px;
        background: #fff;
        position: absolute;
        left: 0;
        top: 50%;
        margin-top: -2px;
        border-radius: 2px
    }

    .iv-close:before {
        -webkit-transform: rotate(45deg);
        -moz-transform: rotate(45deg);
        -ms-transform: rotate(45deg);
        -o-transform: rotate(45deg);
        transform: rotate(45deg)
    }

    .iv-close:after {
        -webkit-transform: rotate(-45deg);
        -moz-transform: rotate(-45deg);
        -ms-transform: rotate(-45deg);
        -o-transform: rotate(-45deg);
        transform: rotate(-45deg)
    }

    .iv-close:hover {
        -webkit-transform: rotate(90deg);
        -moz-transform: rotate(90deg);
        -ms-transform: rotate(90deg);
        -o-transform: rotate(90deg);
        transform: rotate(90deg)
    }

    .iv-image-view {
        position: absolute;
        height: 100%;
        width: 100%
    }

    .iv-image-wrap {
        display: inline-block
    }

    .iv-image-wrap:active {
        cursor: move
    }

    .iv-large-image {
        cursor: move;
        max-width: 100%;
        max-height: 100%;
        background-color: #ececec;
        -moz-transform: translateZ(0);
        -o-transform: translateZ(0)
    }

    .iv-large-image, .iv-loader {
        position: absolute;
        -webkit-transform: translateZ(0);
        -ms-transform: translateZ(0);
        transform: translateZ(0)
    }

    .iv-loader {
        top: 50%;
        left: 50%;
        border-radius: 50%;
        width: 32px;
        height: 32px;
        z-index: 100;
        margin-top: -16px;
        margin-left: -16px;
        font-size: 5px;
        text-indent: -9999em;
        border-top: 1em solid hsla(0, 0%, 100%, .2);
        border-right: 1em solid hsla(0, 0%, 100%, .2);
        border-bottom: 1em solid hsla(0, 0%, 100%, .2);
        border-left: 1em solid #fff;
        -webkit-animation: load8 1.1s infinite linear;
        animation: load8 1.1s infinite linear
    }

    .iv-loader:after {
        width: 10em;
        height: 10em;
        border-radius: 50%
    }

    @-webkit-keyframes load8 {
        0% {
            -webkit-transform: rotate(0deg);
            transform: rotate(0deg)
        }
        to {
            -webkit-transform: rotate(1turn);
            transform: rotate(1turn)
        }
    }

    @keyframes load8 {
        0% {
            -webkit-transform: rotate(0deg);
            transform: rotate(0deg)
        }
        to {
            -webkit-transform: rotate(1turn);
            transform: rotate(1turn)
        }
    }</style>
    <style type="text/css">.vue-pull-to-wrapper[data-v-12abd9fb] {
        display: -webkit-box;
        display: -webkit-flex;
        display: flex;
        -webkit-box-orient: vertical;
        -webkit-box-direction: normal;
        -webkit-flex-direction: column;
        flex-direction: column;
        height: 100%
    }

    .scroll-container[data-v-12abd9fb] {
        -webkit-box-flex: 1;
        -webkit-flex: 1;
        flex: 1;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch
    }

    .vue-pull-to-wrapper .action-block[data-v-12abd9fb] {
        position: relative;
        width: 100%
    }

    .default-text[data-v-12abd9fb] {
        height: 100%;
        line-height: 50px;
        text-align: center
    }</style>
    <style type="text/css">.button-cancel[data-v-87ffcada] {
        color: #888;
        border: 1px solid #888;
        border-radius: 3px;
        margin-right: 12px
    }

    .button-cancel[data-v-87ffcada], .button-primary[data-v-87ffcada] {
        -webkit-box-flex: 1;
        -ms-flex-positive: 1;
        flex-grow: 1;
        height: 35px;
        display: inline-block;
        font-size: 15px;
        text-align: center;
        line-height: 36px
    }

    .button-primary[data-v-87ffcada] {
        color: #fff;
        background-color: #ff5a05;
        border-radius: 3px
    }

    .pd[data-v-87ffcada] {
        padding-left: 1.375rem;
        padding-right: 1.375rem
    }

    .article[data-v-87ffcada] {
        max-width: 46.25rem;
        margin: 0 auto
    }

    .article .article-unavailable[data-v-87ffcada] {
        color: #fa8919;
        font-size: 15px;
        font-weight: 600;
        line-height: 24px;
        border-radius: 5px;
        padding: 12px;
        background-color: #f6f7fb;
        margin-top: 20px
    }

    .article .article-unavailable .iconfont[data-v-87ffcada] {
        font-size: 12px
    }

    .article .main[data-v-87ffcada] {
        padding: 1.25rem 0;
        margin-bottom: 52px
    }

    .article-title[data-v-87ffcada] {
        color: #353535;
        font-weight: 400;
        line-height: 1.65rem;
        font-size: 1.34375rem
    }

    .article-info[data-v-87ffcada] {
        color: #888;
        font-size: .9375rem;
        margin-top: 1.0625rem
    }

    .article-content[data-v-87ffcada] {
        margin-top: 1.0625rem
    }

    .article-content.android video[data-v-87ffcada]::-webkit-media-controls-fullscreen-button {
        display: none
    }

    .copyright[data-v-87ffcada] {
        color: #b2b2b2;
        padding-bottom: 20px;
        margin-top: 20px;
        font-size: 13px
    }

    .audio-player[data-v-87ffcada] {
        width: 100%;
        margin: 20px 0
    }

    .to-comment[data-v-87ffcada] {
        overflow: hidden;
        padding-top: 10px;
        margin-bottom: -30px
    }

    .to-comment a.button-primary[data-v-87ffcada] {
        float: right;
        height: 20px;
        font-size: 12px;
        line-height: 20px;
        padding: 4px 8px;
        cursor: pointer
    }

    .article-comments[data-v-87ffcada] {
        margin-top: 2rem
    }

    .article-comments h2[data-v-87ffcada] {
        text-align: center;
        color: #888;
        position: relative;
        z-index: 1;
        margin-bottom: 1rem
    }

    .article-comments h2[data-v-87ffcada]:before {
        border-top: 1px dotted #888;
        content: "";
        position: absolute;
        top: 56%;
        left: 0;
        width: 100%;
        z-index: -1
    }

    .article-comments h2 span[data-v-87ffcada] {
        font-size: 15.25px;
        font-weight: 400;
        padding: 0 1rem;
        background: #fff;
        display: inline-block
    }

    .article-sub-bottom[data-v-87ffcada] {
        z-index: 10;
        cursor: pointer
    }

    .switch-btns[data-v-87ffcada] {
        height: 76px;
        cursor: pointer;
        padding-top: 24px;
        padding-bottom: 24px;
        border-bottom: 10px solid #f6f7fb;
        position: relative
    }

    .switch-btns[data-v-87ffcada]:before {
        content: " ";
        height: 1px;
        background: #e8e8e8;
        position: absolute;
        top: 0;
        left: 0;
        -webkit-box-sizing: border-box;
        box-sizing: border-box;
        left: 1.375rem;
        right: 1.375rem
    }

    .switch-btns .btn[data-v-87ffcada] {
        height: 38px;
        display: -webkit-box;
        display: -ms-flexbox;
        display: flex;
        -webkit-box-align: center;
        -ms-flex-align: center;
        align-items: center
    }

    .switch-btns .btn .tag[data-v-87ffcada] {
        -webkit-box-flex: 0;
        -ms-flex: 0 0 62px;
        flex: 0 0 62px;
        text-align: center;
        color: #888;
        font-size: 14px;
        border-radius: 10px;
        height: 22px;
        line-height: 22px;
        background: #f6f7fb;
        font-weight: 400
    }

    .switch-btns .btn .txt[data-v-87ffcada] {
        margin-left: 10px;
        -webkit-box-flex: 1;
        -ms-flex: 1 1 auto;
        flex: 1 1 auto;
        color: #888;
        font-size: 15px;
        height: 22px;
        line-height: 22px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        font-weight: 400
    }

    @media (max-width: 769px) {
        .article .breadcrumb[data-v-87ffcada] {
            padding-top: 10px;
            padding-bottom: 10px
        }
    }</style>
    <style type="text/css">.empty {
        height: 51px
    }

    .mobile-tips {
        width: 100%;
        height: 51px;
        background: rgba(0, 0, 0, .8);
        position: fixed;
        top: 0;
        left: 0;
        z-index: 20;
        display: -webkit-box;
        display: -ms-flexbox;
        display: flex;
        -webkit-box-orient: horizontal;
        -webkit-box-direction: normal;
        -ms-flex-direction: row;
        flex-direction: row;
        -webkit-box-align: center;
        -ms-flex-align: center;
        align-items: center;
        -webkit-box-pack: justify;
        -ms-flex-pack: justify;
        justify-content: space-between;
        -webkit-box-sizing: border-box;
        box-sizing: border-box;
        padding: 0 12px;
        -webkit-transition: opacity .35s;
        transition: opacity .35s;
        opacity: 0;
        pointer-events: none
    }

    .mobile-tips.istop {
        opacity: 1;
        pointer-events: auto
    }

    .mobile-tips .mobile-tips-info {
        display: -webkit-box;
        display: -ms-flexbox;
        display: flex;
        -webkit-box-orient: horizontal;
        -webkit-box-direction: normal;
        -ms-flex-direction: row;
        flex-direction: row;
        -webkit-box-align: center;
        -ms-flex-align: center;
        align-items: center;
        -webkit-box-pack: start;
        -ms-flex-pack: start;
        justify-content: flex-start
    }

    .mobile-tips .mobile-tips-info i {
        width: 36px;
        height: 36px;
        background-image: url(data:image/png;base64,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);
        background-position: 0 0;
        background-repeat: no-repeat;
        background-size: contain;
        border-radius: 7px
    }

    .mobile-tips .mobile-tips-info h2 {
        font-size: 15px;
        color: #fff;
        font-weight: 400;
        margin-left: 6px
    }

    .mobile-tips .mobile-tips-info h2 span {
        font-size: 11px
    }

    .mobile-tips a {
        width: 72px;
        height: 31px;
        text-align: center;
        border: 1px solid #fa8919;
        border-radius: 3px;
        font-size: 13px;
        color: #fa8919;
        line-height: 31px
    }</style>
    <style type="text/css">.share-poster-wrapper {
        position: fixed;
        background-color: #fff;
        left: 0;
        bottom: 0;
        z-index: 100;
        display: -webkit-box;
        display: -ms-flexbox;
        display: flex;
        overflow: hidden;
        width: 100%;
        -webkit-box-orient: vertical;
        -webkit-box-direction: normal;
        -ms-flex-direction: column;
        flex-direction: column;
        -moz-user-select: -moz-none;
        -webkit-user-select: none;
        -ms-user-select: none;
        user-select: none
    }

    .share-poster-wrapper .poster-bottom, .share-poster-wrapper .poster-middle, .share-poster-wrapper .poster-top {
        -ms-flex-negative: 0;
        flex-shrink: 0
    }

    .share-poster-wrapper .poster-middle {
        padding: 16px 32px;
        -webkit-box-sizing: border-box;
        box-sizing: border-box
    }

    .share-poster-wrapper .poster-middle .poster-userinfo {
        display: -webkit-box;
        display: -ms-flexbox;
        display: flex;
        -webkit-box-align: center;
        -ms-flex-align: center;
        align-items: center;
        padding-bottom: 18px
    }

    .share-poster-wrapper .poster-middle .poster-userinfo .poster-avatar {
        min-width: 45px;
        min-height: 45px;
        width: 7vw;
        height: 7vw;
        border-radius: 50%;
        -ms-flex-negative: 0;
        flex-shrink: 0
    }

    .share-poster-wrapper .poster-middle .nickname {
        font-size: 5vw;
        font-weight: 400;
        margin-left: 18px
    }

    .share-poster-wrapper .poster-middle .time {
        font-size: 3.2vw
    }

    .share-poster-wrapper .poster-middle .poster-middle-content {
        font-size: 4vw;
        font-weight: 400;
        white-space: normal;
        word-wrap: break-word;
        word-break: break-word;
        letter-spacing: 1px
    }

    .share-poster-wrapper .poster-middle .poster-middle-content p {
        margin-bottom: 22px
    }

    .share-poster-wrapper .poster-middle .quote-content {
        font-size: 3.7vw;
        padding: 32px 0
    }

    .share-poster-wrapper .poster-middle .quote-content p {
        margin-bottom: 22px
    }

    .share-poster-wrapper .poster-middle .quote-info {
        border-left: 1px solid #000;
        padding-left: 10px;
        margin-top: 38px
    }

    .share-poster-wrapper .poster-middle .quote-info p {
        font-size: 3.2vw;
        line-height: 1.5
    }

    .share-poster-wrapper.theme0 .poster-top {
        width: 100%;
        height: 25px;
        margin-top: 27px;
        background: url("https://static001.geekbang.org/static/time/page/img/sharePoster/theme1/top.png") no-repeat 15px 1px
    }

    .share-poster-wrapper.theme0 .poster-middle {
        width: 100%;
        padding-left: 56px;
        padding-right: 56px;
        background-image: url("https://static001.geekbang.org/static/time/page/img/sharePoster/theme1/middle.png");
        background-repeat: repeat-y;
        background-position: 15px 0
    }

    .share-poster-wrapper.theme0 .poster-middle .time {
        margin-bottom: 45px
    }

    .share-poster-wrapper.theme0 .poster-middle .quote-content {
        border-top: 1px solid #e3e1dc;
        margin-top: 30px
    }

    .share-poster-wrapper.theme0 .poster-bottom {
        width: 100%;
        height: 25px;
        margin-bottom: 27px;
        background: url("https://static001.geekbang.org/static/time/page/img/sharePoster/theme1/bottom.png") no-repeat 15px -10px
    }

    .share-poster-wrapper.theme1 .poster-top {
        width: 100%;
        height: 25px;
        margin-top: 27px;
        background: url("https://static001.geekbang.org/static/time/page/img/sharePoster/theme0/top.png") no-repeat 38px 1px
    }

    .share-poster-wrapper.theme1 .poster-middle {
        width: 100%;
        padding: 0 42px 10px;
        background: url("https://static001.geekbang.org/static/time/page/img/sharePoster/theme0/middle.png") repeat-y 38px 0
    }

    .share-poster-wrapper.theme1 .poster-middle .poster-userinfo {
        border-bottom: 1px solid #b5a899
    }

    .share-poster-wrapper.theme1 .poster-middle .poster-userinfo .poster-avatar {
        margin-left: 38px
    }

    .share-poster-wrapper.theme1 .poster-middle .poster-middle-wrapper {
        display: -webkit-box;
        display: -ms-flexbox;
        display: flex;
        -webkit-box-orient: horizontal;
        -webkit-box-direction: normal;
        -ms-flex-direction: row;
        flex-direction: row;
        min-height: 260px;
        border-bottom: 1px solid #b5a899
    }

    .share-poster-wrapper.theme1 .poster-middle .time {
        max-width: 65px;
        display: -webkit-box;
        display: -ms-flexbox;
        display: flex;
        -webkit-box-orient: vertical;
        -webkit-box-direction: normal;
        -ms-flex-direction: column;
        flex-direction: column;
        -webkit-box-pack: center;
        -ms-flex-pack: center;
        justify-content: center;
        -webkit-box-align: center;
        -ms-flex-align: center;
        align-items: center;
        text-align: center;
        vertical-align: middle;
        border-right: 1px solid #b5a899
    }

    .share-poster-wrapper.theme1 .poster-middle .time span {
        white-space: nowrap;
        -webkit-transform: rotate(90deg);
        transform: rotate(90deg)
    }

    .share-poster-wrapper.theme1 .poster-middle .poster-middle-content {
        padding: 30px
    }

    .share-poster-wrapper.theme1 .poster-middle .quote-content {
        font-size: 3.7vw;
        margin-left: 36px;
        margin-right: 36px
    }

    .share-poster-wrapper.theme1 .poster-middle .quote-info {
        margin-left: 36px;
        margin-right: 36px
    }

    .share-poster-wrapper.theme1 .poster-middle .footer {
        display: -webkit-box;
        display: -ms-flexbox;
        display: flex;
        -webkit-box-orient: horizontal;
        -webkit-box-direction: normal;
        -ms-flex-direction: row;
        flex-direction: row;
        margin-right: 30px
    }

    .share-poster-wrapper.theme1 .poster-bottom {
        width: 100%;
        height: 25px;
        margin-bottom: 27px;
        background: url("https://static001.geekbang.org/static/time/page/img/sharePoster/theme0/bottom.png") no-repeat 38px -10px
    }

    .share-poster-wrapper .share-poster {
        background: #fefdf8;
        -webkit-box-sizing: border-box;
        box-sizing: border-box;
        color: #9b8d73;
        -webkit-box-flex: 1;
        -ms-flex-positive: 1;
        flex-grow: 1;
        overflow: auto;
        display: -webkit-box;
        display: -ms-flexbox;
        display: flex;
        -webkit-box-orient: vertical;
        -webkit-box-direction: normal;
        -ms-flex-direction: column;
        flex-direction: column;
        -webkit-overflow-scrolling: touch;
        -webkit-box-align: center;
        -ms-flex-align: center;
        align-items: center
    }

    .share-poster-wrapper .share-poster.color0 {
        background-color: #fefdf8
    }

    .share-poster-wrapper .share-poster.color1 {
        background-color: #4d4d4d
    }

    .share-poster-wrapper .share-poster .footer {
        margin-top: 2rem;
        position: relative;
        display: -webkit-box;
        display: -ms-flexbox;
        display: flex;
        -webkit-box-orient: horizontal;
        -webkit-box-direction: normal;
        -ms-flex-direction: row;
        flex-direction: row;
        -webkit-box-pack: end;
        -ms-flex-pack: end;
        justify-content: flex-end;
        -webkit-box-align: end;
        -ms-flex-align: end;
        align-items: flex-end
    }

    .share-poster-wrapper .share-poster .footer p {
        margin: 0;
        line-height: 1.4;
        margin-left: 20px;
        text-align: right;
        padding-right: 20px
    }

    .share-poster-wrapper .controls {
        background: #fff;
        border-top: 1px solid #f5f5f5;
        width: 100%;
        padding-top: 5px;
        -webkit-box-shadow: 0 -4px 10px 0 rgba(0, 0, 0, .1);
        box-shadow: 0 -4px 10px 0 rgba(0, 0, 0, .1);
        z-index: 1;
        -ms-flex-negative: 0;
        flex-shrink: 0
    }

    .share-poster-wrapper .controls > div {
        display: -webkit-box;
        display: -ms-flexbox;
        display: flex;
        -webkit-box-orient: horizontal;
        -webkit-box-direction: normal;
        -ms-flex-direction: row;
        flex-direction: row;
        -webkit-box-pack: center;
        -ms-flex-pack: center;
        justify-content: center;
        -webkit-box-align: center;
        -ms-flex-align: center;
        align-items: center;
        padding: 10px 0
    }

    .share-poster-wrapper .controls > div span {
        font-size: .85rem
    }

    .share-poster-wrapper .controls > div button {
        width: 100px;
        height: 24px;
        background: #eee;
        margin: 0 10px;
        border-radius: 5px;
        border: 2px solid #b2b2b2;
        outline: none
    }

    .share-poster-wrapper .controls > div button.on {
        border: 2px solid #ff5a05
    }

    .share-poster-wrapper .controls .controls-themes button {
        color: #b2b2b2;
        font-size: 12px;
        background: #fff;
        text-align: center
    }

    .share-poster-wrapper .controls .controls-themes button.on {
        color: #ff5a05
    }

    .share-poster-wrapper .buttons {
        background: #fff;
        border-top: 1px solid #f5f5f5;
        display: -webkit-box;
        display: -ms-flexbox;
        display: flex;
        -webkit-box-orient: horizontal;
        -webkit-box-direction: normal;
        -ms-flex-direction: row;
        flex-direction: row;
        -ms-flex-negative: 0;
        flex-shrink: 0
    }

    .share-poster-wrapper .buttons a {
        -webkit-box-flex: 1;
        -ms-flex-positive: 1;
        flex-grow: 1;
        text-align: center;
        color: #000;
        font-weight: 400;
        height: 3rem;
        line-height: 3rem
    }

    .share-poster-wrapper .buttons a .icon-share-money {
        width: 1rem;
        height: 1rem;
        margin: 3px 0 0 5px
    }

    .share-poster-wrapper .buttons a:last-child {
        border-left: 1px solid #f5f5f5
    }

    .share-poster-wrapper img {
        max-width: 100%
    }

    .share-poster-wrapper.android .poster-middle .nickname {
        font-size: 10vw
    }

    .share-poster-wrapper.android .poster-middle .time {
        font-size: 6.4vw
    }

    .share-poster-wrapper.android .poster-middle .poster-middle-content {
        font-size: 8vw
    }

    .share-poster-wrapper.android .poster-middle .quote-content {
        font-size: 7.4vw
    }

    .share-poster-wrapper.android .poster-middle .quote-info p {
        font-size: 6.4vw
    }</style>
    <style type="text/css">.mini-audio-player {
        width: 100%;
        height: 5.25rem;
        border: 1px solid #d9d9d9;
        background: #fafafa;
        -webkit-box-sizing: border-box;
        box-sizing: border-box;
        padding: 1rem;
        display: -webkit-box;
        display: -ms-flexbox;
        display: flex;
        -webkit-box-orient: horizontal;
        -webkit-box-direction: normal;
        -ms-flex-direction: row;
        flex-direction: row;
        -webkit-box-align: center;
        -ms-flex-align: center;
        align-items: center;
        -webkit-box-pack: justify;
        -ms-flex-pack: justify;
        justify-content: space-between;
        margin: 1rem 0
    }

    .mini-audio-player > a {
        border: none;
        -ms-flex-negative: 0;
        flex-shrink: 0
    }

    .mini-audio-player .btn-play {
        background-image: url(data:image/png;base64,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)
    }

    .mini-audio-player .btn-pause, .mini-audio-player .btn-play {
        width: 2.6875rem;
        height: 2.6875rem;
        background-repeat: no-repeat;
        background-position: 0 0;
        background-size: contain;
        text-decoration: none
    }

    .mini-audio-player .btn-pause {
        background-image: url(data:image/png;base64,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)
    }

    .mini-audio-player .audio-info {
        display: -webkit-box;
        display: -ms-flexbox;
        display: flex;
        -webkit-box-flex: 1;
        -ms-flex-positive: 1;
        flex-grow: 1;
        -webkit-box-orient: vertical;
        -webkit-box-direction: normal;
        -ms-flex-direction: column;
        flex-direction: column;
        margin-left: .6875rem;
        min-width: 0
    }

    .mini-audio-player .audio-info h3 {
        color: #353535;
        font-size: 15.25px;
        margin: 0;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis
    }

    .mini-audio-player .audio-info p {
        margin: 0;
        margin-top: .125rem;
        font-size: 11px;
        line-height: 1rem
    }

    .mini-audio-player .audio-info p span {
        color: #888
    }

    .mini-audio-player .btn-download {
        width: 1.25rem;
        height: 1.25rem;
        position: relative;
        background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAA+CAYAAACbQR1vAAABS2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxMzggNzkuMTU5ODI0LCAyMDE2LzA5LzE0LTAxOjA5OjAxICAgICAgICAiPgogPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIi8+CiA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgo8P3hwYWNrZXQgZW5kPSJyIj8+IEmuOgAAA4hJREFUaIHtm8lOFFEUhr9qCWGHGxcaY1joK2h0YRzAtYmsWbAGGidEXOACbAYRxfgAPoEPoInGxJgg86gsJTHMw86EhS7O7TDk3uqq6qo6HahvQ7pOce7//1U0feve9vr6+lAiD3QC/4AC8FZDRJXGoMB14PWB1yPANPA1bSG5tAc0XLEcu5y6CvQCOGU5pnI3agVQMWQBaAvQJgtAW4A2WQDaArTJAtAWoE0WgLYAbbIAtAVokwWgLUCbLABtAdpkAfjU6oC7wKV0pCTCRcRDnesEVwDNwC/gg/nZHbeyFOgGltj30Gw7yRZALfAOqDavPeA50BO7xOToQTR75nU14qn26Im2AM4DNZbjz4DeePQlSi+i9Sg1iLdD2AJYApYdzbuo7BBeIBptLCPeDmELYA9oBHYdjbqQpaxKowA8ddR2gXuIt0O43gRHgTu4Q+ikskIoIJps7AINwA9b0e/fYJAQ1FZWD9CP2/wOUI/DPJT+IDRqGrhCeGIEaNEPdDhqO8iVH/NrEOST4BgSwo6j3gEMBOgTNwP4m6+nhHkI/lG4VAiPgcGAveJg0IxpYxvROh6kUZi5wLhpvO2oPyKdEF6asWyEMg/hJ0PjyN+VXwhDIXuGYQh46KhtIeYnwjSMMhss3glbjvoDkglhyPS2Eck8RJ8OTyB3gl8IryL2tjGM2/wmYn4ySuNyngdMmIE3HfX7iHDPUQ+CZ3q0O+qbyIWIZB7KfyAyaQS4QmhH7oQoIZQyv0EZV75IHE+EJvG/E9oJfyd4yC6yvKO+gQQ/FaKnlbgeiU0hIWw46nnEUJAQiubbHPV1M1bZ5iHeZ4KlQmgD3uAfgofsGfQz34DsKYyFuLemTSMhfATOWOqtiMk/llrRfIuj9zpwG5gtX+Y+SezNK4bwCXsILdgDaAXOOnomYh6Seyw+gwhed9TPWY75mb9FAuYh2XWBWUS4K4QgrAE3gblYFFlIemFkDjEQJYQ1JMD5WBUdIY2VoXkkhLUQv7NqfidR85De0liYEFaRK7+QqCJDmmuDC0gIqz7nrJhzUjEP6S+O+oWwglz5xTQFaawOLwI3gO8Hjo2ZY6maB72vzPwErgEXkO8MuVaiEkcrgCK/lcfPNkhkAWgL0KYKmZiMIG9Ktn0Bx5G/wDcgXwW8R6avJ41G4HQOufInlas5ZO5+UpnJAU3AFyy7J44xe8BnoOk/JruwYo92bigAAAAASUVORK5CYII=);
        background-repeat: no-repeat;
        background-position: 0 0;
        background-size: contain;
        text-decoration: none;
        padding-right: .25rem
    }

    .mini-audio-player .btn-download .icon-download-done {
        width: .45rem;
        height: .45rem;
        position: absolute;
        bottom: 0;
        right: 0;
        display: inline-block;
        background-image: url(data:image/png;base64,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);
        background-repeat: no-repeat;
        background-position: 0 0;
        background-size: contain
    }</style>
    <style type="text/css">.MathJax_Display {
        overflow: auto
    }

    .poster {
        position: fixed;
        left: -10000px;
        top: -10000px;
        overflow: hidden;
        padding: 1rem;
        background: #ececec
    }

    .richcontent-pre-copy {
        font-size: 13px;
        color: #888;
        position: absolute;
        right: 1em;
        top: .2em;
        cursor: pointer;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none
    }

    .richcontent-pre-copy .iconfont {
        font-size: 12px;
        margin-right: .2em
    }</style>
    <style type="text/css">.breadcrumb {
        padding: 30px 0;
        display: -webkit-box;
        display: -ms-flexbox;
        display: flex;
        -webkit-box-orient: horizontal;
        -webkit-box-direction: normal;
        -ms-flex-direction: row;
        flex-direction: row;
        -webkit-box-align: center;
        -ms-flex-align: center;
        align-items: center;
        -ms-flex-wrap: wrap;
        flex-wrap: wrap;
        background: #fff
    }

    .breadcrumb a.title {
        color: #e57c39;
        font-size: 15px;
        font-weight: 400
    }

    .breadcrumb span.title {
        color: #888;
        font-size: 15px;
        font-weight: 400
    }

    .breadcrumb .split {
        color: #ccc;
        font-size: 10px;
        margin-right: 5px
    }</style>
    <style type="text/css">.comment-item {
        list-style-position: inside;
        width: 100%;
        display: -webkit-box;
        display: -ms-flexbox;
        display: flex;
        -webkit-box-orient: horizontal;
        -webkit-box-direction: normal;
        -ms-flex-direction: row;
        flex-direction: row;
        margin-bottom: 1rem
    }

    .comment-item a {
        border-bottom: none
    }

    .comment-item .avatar {
        width: 2.625rem;
        height: 2.625rem;
        -ms-flex-negative: 0;
        flex-shrink: 0;
        border-radius: 50%
    }

    .comment-item .info {
        margin-left: .5rem;
        -webkit-box-flex: 1;
        -ms-flex-positive: 1;
        flex-grow: 1
    }

    .comment-item .info .hd {
        width: 100%;
        display: -webkit-box;
        display: -ms-flexbox;
        display: flex;
        -webkit-box-orient: horizontal;
        -webkit-box-direction: normal;
        -ms-flex-direction: row;
        flex-direction: row;
        -webkit-box-pack: justify;
        -ms-flex-pack: justify;
        justify-content: space-between;
        -webkit-box-align: center;
        -ms-flex-align: center;
        align-items: center
    }

    .comment-item .info .hd .username {
        color: #888;
        font-size: 15.25px;
        font-weight: 400;
        line-height: 1.2
    }

    .comment-item .info .hd .control {
        display: -webkit-box;
        display: -ms-flexbox;
        display: flex;
        -webkit-box-orient: horizontal;
        -webkit-box-direction: normal;
        -ms-flex-direction: row;
        flex-direction: row;
        -webkit-box-align: center;
        -ms-flex-align: center;
        align-items: center
    }

    .comment-item .info .hd .control .btn-share {
        color: #888;
        font-size: .75rem;
        margin-right: 1rem
    }

    .comment-item .info .hd .control .btn-praise {
        display: -webkit-box;
        display: -ms-flexbox;
        display: flex;
        -webkit-box-orient: horizontal;
        -webkit-box-direction: normal;
        -ms-flex-direction: row;
        flex-direction: row;
        -webkit-box-align: center;
        -ms-flex-align: center;
        align-items: center;
        font-size: 15.25px;
        text-decoration: none
    }

    .comment-item .info .hd .control .btn-praise i {
        color: #888;
        display: inline-block;
        font-size: .75rem;
        margin-right: .3rem;
        margin-top: -.01rem
    }

    .comment-item .info .hd .control .btn-praise i.on, .comment-item .info .hd .control .btn-praise span {
        color: #fa8919
    }

    .comment-item .info .bd {
        color: #353535;
        font-size: 15.25px;
        font-weight: 400;
        white-space: normal;
        word-break: break-all;
        line-height: 1.6
    }

    .comment-item .info .time {
        color: #888;
        font-size: 9px;
        line-height: 1
    }

    .comment-item .info .reply .reply-hd {
        font-size: 15.25px
    }

    .comment-item .info .reply .reply-hd span {
        margin-left: -12px;
        color: #888;
        font-weight: 400
    }

    .comment-item .info .reply .reply-hd i {
        color: #fa8919;
        font-size: 15.25px
    }

    .comment-item .info .reply .reply-content {
        color: #353535;
        font-size: 15.25px;
        font-weight: 400;
        white-space: normal;
        word-break: break-all
    }

    .comment-item .info .reply .reply-time {
        color: #888;
        font-size: 9px
    }

    .comment-template {
        display: none;
    }
    </style>
</head>
<body>

<div id="app">
    <div data-v-87ffcada="" class="article"><!---->
        <div data-v-87ffcada="" class="main main-app">
            <h1 data-v-87ffcada="" class="article-title pd">
                02 | Java内存模型：看Java如何解决可见性和有序性问题
            </h1>
            <div data-v-87ffcada="" class="article-info pd"><span data-v-87ffcada="">2019-03-02</span> <span data-v-87ffcada="">王宝令</span></div>
            <div data-v-87ffcada="" class="article-content typo common-content pd">
                <img data-v-87ffcada="" src="https://static001.geekbang.org/resource/image/75/ec/756c6a8e1eb77e2f56ca97d4a71f97ec.jpg">
                <!---->
                <div data-v-87ffcada="" class="mini-audio-player">
                    <div class="audio-info">
                        <p><span>朗读人：王宝令&nbsp;&nbsp;&nbsp;</span>
                        </p></div> <!---->
                    <audio title="" src="https://static001.geekbang.org/resource/audio/4e/a9/4e47fabe747154115d55f37975b4bea9.mp3" controls="controls"></audio>
                </div>
                <div data-v-87ffcada="" id="article-content" class="">
                    <div class="text"><p>上一期我们讲到在并发场景中，因可见性、原子性、有序性导致的问题常常会违背我们的直觉，从而成为并发编程的Bug之源。这三者在编程领域属于共性问题，所有的编程语言都会遇到，Java在诞生之初就支持多线程，自然也有针对这三者的技术方案，而且在编程语言领域处于领先地位。理解Java解决并发问题的解决方案，对于理解其他语言的解决方案有触类旁通的效果。</p><p>那我们就先来聊聊如何解决其中的可见性和有序性导致的问题，这也就引出来了今天的主角——<strong>Java内存模型</strong>。</p><p>Java内存模型这个概念，在职场的很多面试中都会考核到，是一个热门的考点，也是一个人并发水平的具体体现。原因是当并发程序出问题时，需要一行一行地检查代码，这个时候，只有掌握Java内存模型，才能慧眼如炬地发现问题。</p><h2>什么是Java内存模型？</h2><p>你已经知道，导致可见性的原因是缓存，导致有序性的原因是编译优化，那解决可见性、有序性最直接的办法就是<strong>禁用缓存和编译优化</strong>，但是这样问题虽然解决了，我们程序的性能可就堪忧了。</p><p>合理的方案应该是<strong>按需禁用缓存以及编译优化</strong>。那么，如何做到“按需禁用”呢？对于并发程序，何时禁用缓存以及编译优化只有程序员知道，那所谓“按需禁用”其实就是指按照程序员的要求来禁用。所以，为了解决可见性和有序性问题，只需要提供给程序员按需禁用缓存和编译优化的方法即可。</p><!-- [[[read_end]]] --><p>Java内存模型是个很复杂的规范，可以从不同的视角来解读，站在我们这些程序员的视角，本质上可以理解为，Java内存模型规范了JVM如何提供按需禁用缓存和编译优化的方法。具体来说，这些方法包括 <strong>volatile</strong>、<strong>synchronized</strong> 和 <strong>final </strong>三个关键字，以及六项 <strong>Happens-Before 规则</strong>，这也正是本期的重点内容。</p><h2>使用volatile的困惑</h2><p>volatile关键字并不是Java语言的特产，古老的C语言里也有，它最原始的意义就是禁用CPU缓存。</p><p>例如，我们声明一个volatile变量 <code>volatile int x = 0</code>，它表达的是：告诉编译器，对这个变量的读写，不能使用CPU缓存，必须从内存中读取或者写入。这个语义看上去相当明确，但是在实际使用的时候却会带来困惑。</p><p>例如下面的示例代码，假设线程A执行writer()方法，按照 volatile 语义，会把变量 “v=true” 写入内存；假设线程B执行reader()方法，同样按照 volatile 语义，线程B会从内存中读取变量v，如果线程B看到 “v == true” 时，那么线程B看到的变量x是多少呢？</p><p>直觉上看，应该是42，那实际应该是多少呢？这个要看Java的版本，如果在低于1.5版本上运行，x可能是42，也有可能是0；如果在1.5以上的版本上运行，x就是等于42。</p><pre><code>// 以下代码来源于【参考1】
class VolatileExample {
  int x = 0;
  volatile boolean v = false;
  public void writer() {
    x = 42;
    v = true;
  }
  public void reader() {
    if (v == true) {
      // 这里x会是多少呢？
    }
  }
}
</code></pre><p>分析一下，为什么1.5以前的版本会出现x = 0的情况呢？我相信你一定想到了，变量x可能被CPU缓存而导致可见性问题。这个问题在1.5版本已经被圆满解决了。Java内存模型在1.5版本对volatile语义进行了增强。怎么增强的呢？答案是一项 Happens-Before 规则。</p><h2>Happens-Before 规则</h2><p>如何理解 Happens-Before 呢？如果望文生义（很多网文也都爱按字面意思翻译成“先行发生”），那就南辕北辙了，Happens-Before 并不是说前面一个操作发生在后续操作的前面，它真正要表达的是：<strong>前面一个操作的结果对后续操作是可见的</strong>。就像有心灵感应的两个人，虽然远隔千里，一个人心之所想，另一个人都看得到。Happens-Before 规则就是要保证线程之间的这种“心灵感应”。所以比较正式的说法是：Happens-Before 约束了编译器的优化行为，虽允许编译器优化，但是要求编译器优化后一定遵守 Happens-Before 规则。</p><p>Happens-Before 规则应该是Java内存模型里面最晦涩的内容了，和程序员相关的规则一共有如下六项，都是关于可见性的。</p><p>恰好前面示例代码涉及到这六项规则中的前三项，为便于你理解，我也会分析上面的示例代码，来看看规则1、2和3到底该如何理解。至于其他三项，我也会结合其他例子作以说明。</p><h3>1. 程序的顺序性规则</h3><p>这条规则是指在一个线程中，按照程序顺序，前面的操作 Happens-Before 于后续的任意操作。这还是比较容易理解的，比如刚才那段示例代码，按照程序的顺序，第6行代码 “x = 42;” Happens-Before 于第7行代码 “v = true;”，这就是规则1的内容，也比较符合单线程里面的思维：程序前面对某个变量的修改一定是对后续操作可见的。</p><p><span class="orange">（为方便你查看，我将那段示例代码在这儿再呈现一遍）</span></p><pre><code>// 以下代码来源于【参考1】
class VolatileExample {
  int x = 0;
  volatile boolean v = false;
  public void writer() {
    x = 42;
    v = true;
  }
  public void reader() {
    if (v == true) {
      // 这里x会是多少呢？
    }
  }
}
</code></pre><h3>2. volatile变量规则</h3><p>这条规则是指对一个volatile变量的写操作， Happens-Before 于后续对这个volatile变量的读操作。</p><p>这个就有点费解了，对一个volatile变量的写操作相对于后续对这个volatile变量的读操作可见，这怎么看都是禁用缓存的意思啊，貌似和1.5版本以前的语义没有变化啊？如果单看这个规则，的确是这样，但是如果我们关联一下规则3，就有点不一样的感觉了。</p><h3>3. 传递性</h3><p>这条规则是指如果A Happens-Before B，且B Happens-Before C，那么A Happens-Before C。</p><p>我们将规则3的传递性应用到我们的例子中，会发生什么呢？可以看下面这幅图：</p><p><img src="https://static001.geekbang.org/resource/image/b1/e1/b1fa541e98c74bc2a033d9ac5ae7fbe1.png" alt=""></p><center><span class="reference">示例代码中的传递性规则</span></center><p>从图中，我们可以看到：</p><ol>
<li>“x=42” Happens-Before 写变量 “v=true” ，这是规则1的内容；</li>
<li>写变量“v=true” Happens-Before 读变量 “v=true”，这是规则2的内容 。</li>
</ol><p>再根据这个传递性规则，我们得到结果：“x=42” Happens-Before 读变量“v=true”。这意味着什么呢？</p><p>如果线程B读到了“v=true”，那么线程A设置的“x=42”对线程B是可见的。也就是说，线程B能看到 “x == 42” ，有没有一种恍然大悟的感觉？这就是1.5版本对volatile语义的增强，这个增强意义重大，1.5版本的并发工具包（java.util.concurrent）就是靠volatile语义来搞定可见性的，这个在后面的内容中会详细介绍。</p><h3>4. 管程中锁的规则</h3><p>这条规则是指对一个锁的解锁 Happens-Before 于后续对这个锁的加锁。</p><p>要理解这个规则，就首先要了解“管程指的是什么”。<strong>管程</strong>是一种通用的同步原语，在Java中指的就是synchronized，synchronized是Java里对管程的实现。</p><p>管程中的锁在Java里是隐式实现的，例如下面的代码，在进入同步块之前，会自动加锁，而在代码块执行完会自动释放锁，加锁以及释放锁都是编译器帮我们实现的。</p><pre><code>synchronized (this) { //此处自动加锁
  // x是共享变量,初始值=10
  if (this.x &lt; 12) {
    this.x = 12; 
  }  
} //此处自动解锁
</code></pre><p>所以结合规则4——管程中锁的规则，可以这样理解：假设x的初始值是10，线程A执行完代码块后x的值会变成12（执行完自动释放锁），线程B进入代码块时，能够看到线程A对x的写操作，也就是线程B能够看到x==12。这个也是符合我们直觉的，应该不难理解。</p><h3>5. 线程 start() 规则</h3><p>这条是关于线程启动的。它是指主线程A启动子线程B后，子线程B能够看到主线程在启动子线程B前的操作。</p><p>换句话说就是，如果线程A调用线程B的 start() 方法（即在线程A中启动线程B），那么该start()操作 Happens-Before 于线程B中的任意操作。具体可参考下面示例代码。</p><pre><code>Thread B = new Thread(()-&gt;{
  // 主线程调用B.start()之前
  // 所有对共享变量的修改，此处皆可见
  // 此例中，var==77
});
// 此处对共享变量var修改
var = 77;
// 主线程启动子线程
B.start();
</code></pre><h3>6. 线程 join() 规则</h3><p>这条是关于线程等待的。它是指主线程A等待子线程B完成（主线程A通过调用子线程B的join()方法实现），当子线程B完成后（主线程A中join()方法返回），主线程能够看到子线程的操作。当然所谓的“看到”，指的是对<strong>共享变量</strong>的操作。</p><p>换句话说就是，如果在线程A中，调用线程B的 join() 并成功返回，那么线程B中的任意操作Happens-Before 于该 join() 操作的返回。具体可参考下面示例代码。</p><pre><code>Thread B = new Thread(()-&gt;{
  // 此处对共享变量var修改
  var = 66;
});
// 例如此处对共享变量修改，
// 则这个修改结果对线程B可见
// 主线程启动子线程
B.start();
B.join()
// 子线程所有对共享变量的修改
// 在主线程调用B.join()之后皆可见
// 此例中，var==66
</code></pre><h2>被我们忽视的final</h2><p>前面我们讲volatile为的是禁用缓存以及编译优化，我们再从另外一个方面来看，有没有办法告诉编译器优化得更好一点呢？这个可以有，就是<strong>final关键字</strong>。</p><p><strong>final修饰变量时，初衷是告诉编译器：这个变量生而不变，可以可劲儿优化。</strong>Java编译器在1.5以前的版本的确优化得很努力，以至于都优化错了。</p><p>问题类似于上一期提到的利用双重检查方法创建单例，构造函数的错误重排导致线程可能看到final变量的值会变化。详细的案例可以参考<a href="http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html#finalWrong">这个文档</a>。</p><p>当然了，在1.5以后Java内存模型对final类型变量的重排进行了约束。现在只要我们提供正确构造函数没有“逸出”，就不会出问题了。</p><p>“逸出”有点抽象，我们还是举个例子吧，在下面例子中，在构造函数里面将this赋值给了全局变量global.obj，这就是“逸出”，线程通过global.obj读取x是有可能读到0的。因此我们一定要避免“逸出”。</p><pre><code>// 以下代码来源于【参考1】
final int x;
// 错误的构造函数
public FinalFieldExample() { 
  x = 3;
  y = 4;
  // 此处就是讲this逸出，
  global.obj = this;
}
</code></pre><h2>总结</h2><p>Java的内存模型是并发编程领域的一次重要创新，之后C++、C#、Golang等高级语言都开始支持内存模型。Java内存模型里面，最晦涩的部分就是Happens-Before规则了，Happens-Before规则最初是在一篇叫做<strong>Time, Clocks, and the Ordering of Events in a Distributed System</strong>的论文中提出来的，在这篇论文中，Happens-Before的语义是一种因果关系。在现实世界里，如果A事件是导致B事件的起因，那么A事件一定是先于（Happens-Before）B事件发生的，这个就是Happens-Before语义的现实理解。</p><p>在Java语言里面，Happens-Before的语义本质上是一种可见性，A Happens-Before B 意味着A事件对B事件来说是可见的，无论A事件和B事件是否发生在同一个线程里。例如A事件发生在线程1上，B事件发生在线程2上，Happens-Before规则保证线程2上也能看到A事件的发生。</p><p>Java内存模型主要分为两部分，一部分面向你我这种编写并发程序的应用开发人员，另一部分是面向JVM的实现人员的，我们可以重点关注前者，也就是和编写并发程序相关的部分，这部分内容的核心就是Happens-Before规则。相信经过本章的介绍，你应该对这部分内容已经有了深入的认识。</p><h2>课后思考</h2><p>有一个共享变量 abc，在一个线程里设置了abc的值 <code>abc=3</code>，你思考一下，有哪些办法可以让其他线程能够看到<code>abc==3</code>？</p><p>欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。</p><h2>参考</h2><ol>
<li><a href="http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html">JSR 133 (Java Memory Model) FAQ</a></li>
<li><a href="http://ifeve.com/jmm-faq/">Java内存模型FAQ</a></li>
<li><a href="https://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf">JSR-133: Java<sup>TM</sup> Memory Model and Thread Specification</a></li>
</ol><p><img src="https://static001.geekbang.org/resource/image/cf/aa/cf393cd748a4f0e6451807c4b61843aa.jpg" alt=""></p></div>
                </div> <!---->
                <div data-v-87ffcada="" class="copyright">
                    ©版权归极客邦科技所有，未经许可不得转载
                </div>
            </div>
            <div data-v-87ffcada="" class="article-comments pd"><h2 data-v-87ffcada=""><span data-v-87ffcada="">精选留言</span></h2>
                <ul data-v-87ffcada="">

                    <li data-v-87ffcada="" class="comment-item comment-template">
                        <img src="${user_header}" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">${user_name}</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">${like_count}</span></a></div>
                            </div>
                            <div class="bd comment-content">${comment_content}
                            </div>
                            <span class="time">${comment_ctime}</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">${user_name}</span></div>
                                <p class="reply-content">${content}</p>
                                <p class="reply-time">${ctime}</p></div>
                        </div>
                    </li>
                <li data-v-87ffcada="" class="comment-item">
                        <img src="" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">Handongyang</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">296</span></a></div>
                            </div>
                            <div class="bd comment-content">老师，还差两个规则，分别是：<br>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。<br>对象终结规则：一个对象的初始化完成(构造函数执行结束)先行发生于它的finalize()方法的开始。<br><br>所以，个人对于Java内存模型总结起来就是：<br>1. 为什么定义Java内存模型？现代计算机体系大部是采用的对称多处理器的体系架构。每个处理器均有独立的寄存器组和缓存，多个处理器可同时执行同一进程中的不同线程，这里称为处理器的乱序执行。在Java中，不同的线程可能访问同一个共享或共享变量。如果任由编译器或处理器对这些访问进行优化的话，很有可能出现无法想象的问题，这里称为编译器的重排序。除了处理器的乱序执行、编译器的重排序，还有内存系统的重排序。因此Java语言规范引入了Java内存模型，通过定义多项规则对编译器和处理器进行限制，主要是针对可见性和有序性。<br>2. 三个基本原则：原子性、可见性、有序性。<br>3. Java内存模型涉及的几个关键词：锁、volatile字段、final修饰符与对象的安全发布。其中：第一是锁，锁操作是具备happens-before关系的，解锁操作happens-before之后对同一把锁的加锁操作。实际上，在解锁的时候，JVM需要强制刷新缓存，使得当前线程所修改的内存对其他线程可见。第二是volatile字段，volatile字段可以看成是一种不保证原子性的同步但保证可见性的特性，其性能往往是优于锁操作的。但是，频繁地访问 volatile字段也会出现因为不断地强制刷新缓存而影响程序的性能的问题。第三是final修饰符，final修饰的实例字段则是涉及到新建对象的发布问题。当一个对象包含final修饰的实例字段时，其他线程能够看到已经初始化的final实例字段，这是安全的。<br>4. Happens-Before的7个规则：<br>	(1).程序次序规则：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。<br>	(2).管程锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而"后面"是指时间上的先后顺序。<br>	(3).volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的"后面"同样是指时间上的先后顺序。<br>	(4).线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作。<br>	(5).线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join（）方法结束、Thread.isAlive（）的返回值等手段检测到线程已经终止执行。<br>	(6).线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。<br>	(7).对象终结规则：一个对象的初始化完成(构造函数执行结束)先行发生于它的finalize()方法的开始。<br>5. Happens-Before的1个特性：传递性。<br>6. Java内存模型底层怎么实现的？主要是通过内存屏障(memory barrier)禁止重排序的，即时编译器根据具体的底层体系架构，将这些内存屏障替换成具体的 CPU 指令。对于编译器而言，内存屏障将限制它所能做的重排序优化。而对于处理器而言，内存屏障将会导致缓存的刷新操作。比如，对于volatile，编译器将在volatile字段的读写操作前后各插入一些内存屏障。</div>
                            <span class="time">2019-03-02</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">厉害厉害！！！</p>
                                <p class="reply-time">2019-03-02</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">senekis</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">66</span></a></div>
                            </div>
                            <div class="bd comment-content"><br>我思考下认为有三种方式可以实现:<br>1.声明共享变量abc，并使用volatile关键字修饰abc<br>2.声明共享变量abc，在synchronized关键字对abc的赋值代码块加锁，由于Happen-before管程锁的规则，可以使得后续的线程可以看到abc的值。<br>3.A线程启动后，使用A.JOIN()方法来完成运行，后续线程再启动，则一定可以看到abc==3<br><br>如有错误，请给指出错误所在！谢谢大家！谢谢老师！<br><br>听课后感觉对我帮助好大，以前零碎的知识被重新系统的整理。错误的理解也得到修正，感谢老师！</div>
                            <span class="time">2019-03-02</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">这三种方式都正确，理解的不错！</p>
                                <p class="reply-time">2019-03-02</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/0f/54/44/4e541a86.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">Junzi</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">44</span></a></div>
                            </div>
                            <div class="bd comment-content">参考1中write()方法代码：<br>x=45;  // 1<br>v=true;  // 2<br>这两行会不会导致指令重排？<br><br>因为volatile关键字应该只保证了变量v的可见性，happen-before第一条原则在单线程中，1与2重排并不影响结果，那应该有可能出现重排的情况，这样线程B读取到read()的时候也有可能出现x=0。还请老师解答。</div>
                            <span class="time">2019-03-04</span>
                            
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJUzv6S9wroydkGP6m3OsQ8QuI4jAibv21tNkm7KVGPffJibj8Y29yIdKl4qkDGd3iaGJCSGVarfxoibQ/132" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">狂战俄洛伊</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">29</span></a></div>
                            </div>
                            <div class="bd comment-content">回复tracer的问题@tracer，你说的这个问题其实就是一个happens-before原则。例如有以下代码：<br>     int a = 1;//代码1<br>     int b = 2;//代码2<br>     volatile int c = 3;//代码3<br>     int d = 4;//代码4<br>     int e = 5;//代码5<br>编译器解释这5行代码的时候，会保证代码1和代码2会在代码3之前执行，而代码1和代码2的执行顺序则不一定（这就是重排序，在不影响执行结果的情况下，虚拟机可能会对命令重排。当然所谓的不影响执行结果，java只保证在单线程中不影响执行结果）。代码4和代码5也一定会在代码3之后执行，同理代码4和代码5的执行顺序也是不一定的。<br>    所以这篇文章中你说的那段代码，由于v是volatile修饰的，对v的赋值永远在对x的赋值之后。所以在reader中输出的x一定是42</div>
                            <span class="time">2019-03-02</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">感谢回复！</p>
                                <p class="reply-time">2019-03-02</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">Jerry银银</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">18</span></a></div>
                            </div>
                            <div class="bd comment-content">思考题的通用性表述为：如何保证一个共享变量的可见性？<br>有以下方法：<br>1. 保证共享变量的可见性，使用volatile关键字修饰即可<br>2. 保证共享变量是private，访问变量使用set/get方法，使用synchronized对方法加锁，此种方法不仅保证了可见性，也保证了线程安全<br>3. 使用原子变量，例如：AtomicInteger等<br>4. 最后一种不是办法的办法：保证多个线程是「串行执行」^_^</div>
                            <span class="time">2019-03-02</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">很全面了!</p>
                                <p class="reply-time">2019-03-02</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/13/36/d2/c7357723.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">发条橙子 。</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">17</span></a></div>
                            </div>
                            <div class="bd comment-content">感悟 ： <br>老师用第一篇介绍了造成并发问题的由来引出了此文如果解决其中的 可见性、排序性问题 。 有了第一篇做铺垫让此篇看起来更加的流畅 。 <br><br>尤其以前看书中讲解 happens-before原则只是单单把六个规则点列了出来，很难吃透。此篇文章给出详细的事例逐点分析，使得更好的去理解每个点。 <br><br>例如 我之前看到的文章都说 在单线程中不会出现有序性问题 ，在多线程中会出现有序性问题。 之前很难理解单线程中没有有序性的问题是什么原因， 原来是happens-before第一条规则限制住了编译器的优化<br><br>问题： <br>第一个例子中添加了 volatile 关键字， 如果例子中 ， v变量没有使用volatile ，那么x会是什么呢 ？？<br>答案： 42<br><br>我的思考是， 没有了volatile那么规则二就不满足 ， 但是规则一和规则三还是满足 ，虽然 writer()方法修改 v不能让其他立即可见，但是如果是循环调用reader()方法 ，等到可见到 v == true，根据第一条原则 ， x happens-before v ，所以能读到 x=42 <br><br>老师请问我的判断正确么？<br><br><br>思考题 ：<br><br>一个共享变量在一个线程中修改让另其他线程可见， 那就是解决可见性（缓存）的问题 , happens-before的规则就是用于对可见性进行约束的<br><br>按照老师课中所讲 ：<br>思考如下：<br><br>  1. 第一条规则同线程中编译会保证顺序性 ， 和问题不符合 <br><br> 2. 第二条规则 ， 使用volatile关键字 ， 这个关键字可以让其他线程写之前先读最新的值，所以保证读到的是最新的值 ，可行<br><br>3. 第三条规则 ，传递性， 和问题不符<br><br>4. 第四条规则， 使用管程，由于是访问共享变量，如果是在syn中修改值只能保证当前线程下一次进入syn可以看见最新的值，其他线程直接访问还可能不是最新值 ， 不行<br><br>5. 第五条规则 ， 如果前提是其他线程都在 主线程修改abc变量后 start()，则可见<br><br>6. 第六条规则 ，如果前提是其他线程等 修改abc变量线程 join()执行，则可见<br><br>  7.   Final关键字， 由于final关键字表示已经定义了常量，任意线程都不可以修改， 不可用 <br><br>综上总结 ： <br><br>使用2 添加volatile可行 。在符合某些场景下时，56可让其他线程可见<br><br><br></div>
                            <span class="time">2019-03-02</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">你分析的比我还要好！</p>
                                <p class="reply-time">2019-03-02</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/12/61/94/713b38ef.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">小和尚笨南北</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">15</span></a></div>
                            </div>
                            <div class="bd comment-content">补充一个： 在abc赋值后对一个volatile变量A进行赋值操作，然后在其他线程读取abc之前读取A的值，通过volatile的可见性和happen-before的传递性实现abc修改后对其他线程立即可见</div>
                            <span class="time">2019-03-02</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">这个我称为炫技！</p>
                                <p class="reply-time">2019-03-03</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/11/29/9e/380a01ea.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">tracer</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">13</span></a></div>
                            </div>
                            <div class="bd comment-content">我明白了，写先于读指的是不会因为cpu缓存，导致a线程已经写了，但是b线程没读到的情况。我错误理解成了b要读，一定要等a写完才行</div>
                            <span class="time">2019-03-02</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">终于理解了！</p>
                                <p class="reply-time">2019-03-02</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/11/e9/0b/1171ac71.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">WL</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">10</span></a></div>
                            </div>
                            <div class="bd comment-content">想问一下老师最后关于逸出的例子，是因为有可能通过global.obj 可能访问到还没有初始化的this对象吗，但是将this赋值给global.obj不也是初始化时才赋值的吗，这部分不太理解，请老师指点一下</div>
                            <span class="time">2019-03-02</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">有可能通过global.obj 可能访问到还没有初始化的this对象<br>将this赋值给global.obj时，this还没有初始化完，this还没有初始化完，this还没有初始化完。</p>
                                <p class="reply-time">2019-03-02</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/12/91/71/0b16655d.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">小麦</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">9</span></a></div>
                            </div>
                            <div class="bd comment-content">@发条橙子 ... <br>有问题吧，我是这样理解的，第一条规则是串行语义，在单线程的场景下，优化后的结果会与顺序执行一致，但是不代表对x的写操作会比对v的写先执行，所以多线程下会出现问题。加volatile关键字后，volatile变量在写操作之后会插入一个store屏障（Store屏障，是x86的”sfence“指令，强制所有在store屏障指令之前的store指令，都在该store屏障指令执行之前被执行，并把store缓冲区的数据都刷到CPU缓存。这会使得程序状态对其它CPU可见，这样其它CPU可以根据需要介入。--并发编程网），所以禁止了重排序，这才保证了对x的写操作会比对v的写先执行，然后再根据volatile变量规则跟传递性原则，才保证了x=42对线程B可见。<br><br></div>
                            <span class="time">2019-03-04</span>
                            
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/12/bc/eb/c22ef3a5.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">Nevermore</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">8</span></a></div>
                            </div>
                            <div class="bd comment-content">// 以下代码来源于【参考 1】<br>class VolatileExample {<br>  int x = 0;<br>  volatile boolean v = false;<br>  public void writer() {<br>    x = 42;<br>    v = true;<br>  }<br>  public void reader() {<br>    if (v == true) {<br>      // 这里 x 会是多少呢？<br>    }<br>  }<br>}<br><br><br>感觉老师对这个volatile变量规则这块讲的有点草率，volatile变量的写对于读是可见的，对于程序来说，也就是线程A执行write中的v=true对于reader中的v==true是可见的 ，但是这对于x有什么关系？x并没有被volatile修饰。<br>根据我的理解，volatile强制所修饰的变量及它前边的变量刷新至内存，并且volatile禁止了指令的重排序。<br> <br>望指正<br></div>
                            <span class="time">2019-03-02</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">你的理解是对的，volatile的实现就是这样的。指导JVM这么实现的规范就是内存模型。这个专栏的侧重点是让大家学会写并发程序，至于底层是怎么实现的，有精力和兴趣的同学，可以自己来把握。</p>
                                <p class="reply-time">2019-03-02</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/12/69/c6/513df085.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">强哥</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">7</span></a></div>
                            </div>
                            <div class="bd comment-content">关于java内存模型、jvm内存结构及java对象模型分别深入讲解一下，这样效果更好一些。</div>
                            <span class="time">2019-03-02</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">咱们这个专栏还是专注于并发相关的部分，我怕有人说挂羊头卖狗肉</p>
                                <p class="reply-time">2019-03-02</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/0f/ed/4d/1d1a1a00.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">magict4</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">6</span></a></div>
                            </div>
                            <div class="bd comment-content">老师你好，<br><br>我对『3. 传递性』中您的解释，还是有点疑惑。感觉许多留言的小伙伴们也都有类似的疑惑，还请老师再耐心回答一次。<br><br>您提到：<br>&gt; “x=42” Happens-Before 写变量 “v=true” ，这是规则 1 的内容；<br>我的疑惑：变量 x 和 v 没有任何依赖关系，为什么对 x 的赋值 Happens-Before 对 v 的赋值呢？<br><br>这个 Happens-Before 关系，根据我的理解，不是由规则 1 决定的，而是有 volatile 决定的。如果 v 没有被 volatile 修饰，编译器是可以对 x、v 的赋值语句进行重排的。 不知道我的理解是否有问题？</div>
                            <span class="time">2019-03-04</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">“x=42” Happens-Before 写变量 “v=true”<br>是因为程序顺序就是这么写的：x=42；v=true<br><br>这个案例是综合了 程序的顺序规则+传递规则+volatile 规则<br><br>这三这个规则组合在一起就是你所谓的：“而是有 volatile 决定的”。编译器优化要遵循所有的HB规则。所有，不是一条。所以只有把他们组合在一起才有意义。<br></p>
                                <p class="reply-time">2019-03-04</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/11/14/50/c23cf47d.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">李</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">6</span></a></div>
                            </div>
                            <div class="bd comment-content">老师，第一章里提到程序中x=5；x=6可能被重排。可是今天第一个规则里提到，同一个线程里，是顺序的。这两个不就矛盾了吗？</div>
                            <span class="time">2019-03-03</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">可以重排，但是要保证符合Happens-Before规则，Happens-Before规则关注的是可见性，<br>x=5;<br>y=6;<br>z=x+y;<br>上面的代码重排成这样：<br>y=6;<br>x=5;<br>z=x+y;<br>也是可以的。<br><br>所谓顺序，指的是你可以用顺序的方式推演程序的执行，但是程序的执行不一定是完全顺序的。编译器保证结果一定 == 顺序方式推演的结果<br><br>这几条规则，都是告诉你，可以按照这个规则推演程序的执行。但是编译怎么优化，那就百花齐放了。</p>
                                <p class="reply-time">2019-03-03</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/11/72/b1/a8b272ef.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">飞翔的花狸猫</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">4</span></a></div>
                            </div>
                            <div class="bd comment-content">Happen-before 这个知识点终于理解了，追并发专栏比以前看小说还勤快，盼老师速更啊</div>
                            <span class="time">2019-03-02</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">那小说得写的有多烂！</p>
                                <p class="reply-time">2019-03-02</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/10/1d/13/31ea1b0b.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">峰</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">4</span></a></div>
                            </div>
                            <div class="bd comment-content">我觉得课后题其实就是利用happenbefore规则去构建abc的写入happenfore于另外一个线程的读取。而6条规则中传递性规则是纽带，然后采用比如规则4，就是把abc的赋值加入一同步块，并先执行，同时另外一个线程申请同一把锁即可。其他的也类似。<br><br>java内存模型对程序员来说提供了按需禁止缓存禁止指令重排的方法。这是我第一次看到这么简单又深刻的解释，老师棒棒哒！！！</div>
                            <span class="time">2019-03-02</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">多谢鼓励啊！</p>
                                <p class="reply-time">2019-03-02</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/12/05/32/7440d47d.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">王位庆</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">3</span></a></div>
                            </div>
                            <div class="bd comment-content">@Junzi，您提的问题刚开始我也很疑惑，但查看了java并发编程的艺术，书上写了jdk1.5之后，增强了volatile的内存含义，限制了编译器和处理器对volatile变量和普通变量的重排序。p47页</div>
                            <span class="time">2019-04-03</span>
                            
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/11/09/98/b11c372b.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">鸠翱</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">3</span></a></div>
                            </div>
                            <div class="bd comment-content">对于@Junzi的问题：<br>x=45; // 1<br>v=true; // 2<br>这两行会不会导致指令重排？ 答：不会<br>如果这两行重排序了，那么线程B读取到read()的时候也有可能出现x=0，也就是说线程B看到了v=true却没又看到x=45，这不符合第一条规则（请问老师 这么理解对不对）<br>我课外查询了一下，从实现方法上，volatile的读写前后会插入内存屏障，保证一些操作是无法没重排序的，其中就有对于volatile的写操作之前的动作不会被重排序到之后</div>
                            <span class="time">2019-03-04</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">是这样。</p>
                                <p class="reply-time">2019-03-04</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">null</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">2</span></a></div>
                            </div>
                            <div class="bd comment-content">@发条橙子… 的思考题分析，有些不太准确吧，例如评论里指出的程序顺序性。还有 synchronized 的分析也不太准确吧，synchronized(abc) 可能保证后续操作可见。<br><br>老师是否应该在回复评论时指正，否则童鞋们看到“分析得比我好”的回复，很大可能就照着分析来理解了。</div>
                            <span class="time">2019-04-10</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">synchronized 的分析没有问题，其他线程直接访问还可能不是最新值，我理解直接就是没有使用任何同步手段。<br>即便用 synchronized，用法不对，也达不到效果。<br>语言本来就不准确，留言的同学，写的都很随意，实在不太适合以批判的眼光来看待。</p>
                                <p class="reply-time">2019-04-10</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/12/16/31/2c11ddc6.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">Hello,Hello,Hello Kitty</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">2</span></a></div>
                            </div>
                            <div class="bd comment-content">x = 42;<br>v = true;<br>老师 我想请假一下 x并没有加volatile修饰 JVM是如何保证x的结果也是被可见呢 是因为x跟v都在同一个寄存器中 voatile修饰的v被刷新回内存的时候 整个寄存器中的值都被刷新到内存中了吗？<br></div>
                            <span class="time">2019-03-11</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">这方面，我也很难通透地讲清楚从Java代码到CPU指令的过程，单线程保证x可见很容易，多线程x跟v不能都同时在一个寄存器里。voatile v刷新回内存的时候，所有CPU缓存里的值都会失效。下次访问就能访问到新的了。</p>
                                <p class="reply-time">2019-03-11</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epUXpvIbKKeXWGL2l0CQo3Jwo6UUX0Jcia7I80Nd3RJs3aGiczXe81Ea534szRxLKhyAeZOiclzib8f2Q/132" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">乔宇佳</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">2</span></a></div>
                            </div>
                            <div class="bd comment-content">关于Junzi的问题，你在自己说的时候已经回答了，因为重排后会影响结果，如果重排之后在读的时候可能会读到0<br>如果v之前有多条指令，那么之前的那多条指令会重排因为那不会影响结果，如果只有这两条，是不会重排的。<br><br>第一次回留言，语言组织的不太好，望老师指正！</div>
                            <span class="time">2019-03-06</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">是的，我也觉得实际上不会重排。这个例子只是说理论上会出问题。你回答的比我要好。</p>
                                <p class="reply-time">2019-03-06</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/10/1c/82/74ab79df.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">胡桥</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">2</span></a></div>
                            </div>
                            <div class="bd comment-content">期待解答~<br>对volatile有个疑惑：我对您关于volatile的代码进行了修改，去掉了volatile：<br>public class VolatileExample {<br>	private int x;<br>	private boolean changed = false; <br>	public void set(int x){<br>		this.x = x;<br>		this.changed = true;<br>	}<br>	public int get(){<br>		return x;<br>	}<br>	public boolean changed(){<br>		return changed;<br>	}<br>}<br>然后我用一个线程A来写，另外一个线程B去读，线程B中如果发现没有没有change就sleep一秒。我发现即使不用volatile，两个线程也能(通过while等待)协调得很好。为什么？<br>这是我的测试代码：<br>public class TestVolatileExample {<br><br>	static int pairCount = 1000;<br>	static VolatileExample[] exps = new VolatileExample[pairCount];<br>	static{<br>		for(int i = 0;i&lt;pairCount;i++){<br>			exps[i] = new VolatileExample();<br>		}<br>	}<br>	<br>	@Test<br>	public void test() throws InterruptedException{<br>		final int valuePair[][] = new int[pairCount][2];<br>		Thread[] threads = new Thread[pairCount*2];<br>		for(int i = 0;i&lt;pairCount;i++){<br>			final int index = i;<br>			//final VolatileExample exp = new VolatileExample();<br>			//writer<br>			Thread writer = new Thread(new Runnable(){<br>				@Override<br>				public void run() {<br>					VolatileExample exp = exps[index];<br>					int val = new Random().nextInt(100);<br>					valuePair[index][0] = val;<br>					exp.set(val);<br>				}<br>			});<br>			writer.start();<br>			threads[i*2] = writer;<br>			//reader<br>			Thread reader = new Thread(new Runnable(){<br>				@Override<br>				public void run() {<br>					VolatileExample exp = exps[index];<br>					while(!exp.changed()){<br>						try {<br>							Thread.sleep(1);<br>						} catch (InterruptedException e) {<br>							e.printStackTrace();<br>						}<br>					}<br>					int val = exp.get();<br>					valuePair[index][1] = val;<br>				}<br>				<br>			});<br>			reader.start();<br>			threads[i*2+1] = reader;<br>		}<br>		for(Thread t : threads){<br>			t.join();<br>		}<br>		for(int i = 0;i&lt;pairCount;i++){<br>			int write = valuePair[i][0];<br>			int read =  valuePair[i][1];<br>			System.out.println(write+"," + read);<br>			Assert.assertEquals(write,read);<br>		}<br>	}<br>}<br></div>
                            <span class="time">2019-03-05</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">并发问题，都是概率性的问题。线程不安全，也不是说每次都能重现。尤其是这种重排的。我也没能重现出来。</p>
                                <p class="reply-time">2019-03-05</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/12/d0/03/2e632d36.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">Geek_c42505</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">2</span></a></div>
                            </div>
                            <div class="bd comment-content">1. 使用volatile修饰abc -禁止cpu缓存直接从内存获取和volatile写 happens before volatile读。<br>2. synchronized 代码块中操作abc 解锁happens before 加锁。<br>3. 线程A操作共享变量abc然后start方法启动B线程 B线程中可见abc操作。<br>4. 线程A操作共享变量abc，B join A 对于B线程可见。<br>不知道叙述的是否准确，忘老师指正</div>
                            <span class="time">2019-03-05</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">很全面了</p>
                                <p class="reply-time">2019-03-05</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/16/06/96/6ae77c39.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">柳絮飞</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">2</span></a></div>
                            </div>
                            <div class="bd comment-content">王老师，请教一下，为什么这些编译优化规则叫内存模型？jvm的堆和栈应该叫什么？多谢！这样叫是不是容易让人误解</div>
                            <span class="time">2019-03-04</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">内存模型的叫法，是指定jsr规范的人定的。堆栈可以叫内存结构</p>
                                <p class="reply-time">2019-03-04</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoRiaKX0ulEibbbwM4xhjyMeza0Pyp7KO1mqvfJceiaM6ZNtGpXJibI6P2qHGwBP9GKwOt9LgHicHflBXw/132" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">Geek_ebda96</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">2</span></a></div>
                            </div>
                            <div class="bd comment-content">我理解的volatile 在操作系统层面，在修改变量的值时候，cpu缓存锁还是要加锁，修改完成后从缓存写入内存，锁才释放，锁的过程中，其他线程读是要等待写入完成，只不过这个锁的时间很短，所以一般感受不出来吧，不然线程a写入还没完成，线程b读取变量值不是最新的，这才能保证写对读可见性，望指正</div>
                            <span class="time">2019-03-04</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">在CPU层面，可能会锁总线，将其他核里的缓存置失效。但是在Java里面volatile 除了这些之外，还涉及到H-B规则。所以volatile 不仅仅是你理解的这些。</p>
                                <p class="reply-time">2019-03-04</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/13/f3/b1/0429aa3b.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">青冰白夜</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">2</span></a></div>
                            </div>
                            <div class="bd comment-content">那老师，就我的那个问题，<br>int i=0 ;<br>int j=1;<br>您也说了，可能重排序成<br>int j=1;<br>int i=0;<br>那int i=0明明是在前面，这重排序在后面，不就不符合happens-befor的程序顺序性规则了吗？</div>
                            <span class="time">2019-03-03</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">int func() {<br>  int i=0;<br>  int j=1;<br>  return i+j;<br>} <br>对于上面这个函数，前面两行的顺序，对于执行结果没有影响。所以编译器可以优化。<br><br>这里所有的happens-before规则，只是说你可以利用他们推演程序运行的结果。编译器优化后的结果一定==你推演的结果。至于中间过程，编译器还是可以优化的。</p>
                                <p class="reply-time">2019-03-03</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/11/b7/f0/a570f68a.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">wang</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">2</span></a></div>
                            </div>
                            <div class="bd comment-content">老师。对呀 发条橙子 提到如果不加 volatile，当读到v的时候，x就一定能读到42，使用的是使用的是规则1。<br>我认为不对呀，规则一不是只适用于单线程吗？而读取v是在另一个线程，所以不能使用规则一判断吧。<br>希望老师可以解释一下，谢谢</div>
                            <span class="time">2019-03-02</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">不加volatile，多线程会有问题</p>
                                <p class="reply-time">2019-03-03</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/15/e5/a5/fae40ac3.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">倚梦流</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">2</span></a></div>
                            </div>
                            <div class="bd comment-content">这里实例里的共享变量为什么没有用static修饰？是因为这里的线程操作的都是同一个实例，所以共享变量不需要用static修饰吗？如果用了static，结果应该也是一样的吧</div>
                            <span class="time">2019-03-02</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">是这样的，多个线程操作一个实例。<br>共享变量不一定用static修饰<br>结果都一样</p>
                                <p class="reply-time">2019-03-02</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/10/ff/ed/b2fc0e7c.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">W要改个网名</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">2</span></a></div>
                            </div>
                            <div class="bd comment-content">volatile标记改变量，<br>syn加锁，<br>lock加锁，<br>join，<br>变为final的静态变量？<br>忘老师点评，谢谢</div>
                            <span class="time">2019-03-02</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">太全面了！</p>
                                <p class="reply-time">2019-03-02</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/15/2f/79/61794fe2.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">拨云见天</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">2</span></a></div>
                            </div>
                            <div class="bd comment-content">@何方妖孽<br>你提的这个问题是java8的新特性之lambda表达式，可以学习下这个新特性，简化代码必备良药哦！</div>
                            <span class="time">2019-03-02</span>
                            
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/11/f9/9b/7db18346.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">mhswordman</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">1</span></a></div>
                            </div>
                            <div class="bd comment-content">老师有个疑问?被volatile关键字修饰的变量，做写操作的时候，文章中的意思直接操作内存，而相关书籍中会说操作缓存，只是Cpu立马会发出指令将缓存中的数据刷新到内存中？具体哪一个比较正确呢？</div>
                            <span class="time">2019-04-30</span>
                            
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/0f/ae/00/025f37e7.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">xuery</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">1</span></a></div>
                            </div>
                            <div class="bd comment-content">对于hb的第一条规则：程序的顺序性规则理解了好久，终于明白了。<br>在一个线程中，按照程序顺序，前面的操作hb于后面的操作，这里的程序顺序是指<br>程序一定是按照顺序执行的（也可能是排序之后的顺序）,并不是指代码书写的先后顺序；<br>比如：x = 42; v = true; 因为v是volatile修饰的，所以x=42一定是先于v=true执行，所以x=42操作hb于v=true;<br>如果v不是volatile修饰的，则由于指令重排指向顺序可能是：x=42;v=true;（1）或者v=true;x=42;（2）<br>如果是第一种顺序则按照规则1，x=42 hb于v=true;第二种顺序则按照规则1，v=true hb于x=42，所以当v=true时，x不一定是42</div>
                            <span class="time">2019-04-18</span>
                            
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/16/1e/4e/adb2f429.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">7℃</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">1</span></a></div>
                            </div>
                            <div class="bd comment-content">老师 您好<br>我看Java并发编程实践中的竞态条件和有序性的描述很像 请问其中竞态条件就是有序性吗？</div>
                            <span class="time">2019-03-15</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">不是，有序性和指令重排有关，即便没有有序性问题，也有可能存在竞态条件问题<br></p>
                                <p class="reply-time">2019-03-15</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/13/f6/f1/5ccbe3fe.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">老醋</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">1</span></a></div>
                            </div>
                            <div class="bd comment-content">还有使用原子变量cas来保障</div>
                            <span class="time">2019-03-11</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">高手！</p>
                                <p class="reply-time">2019-03-11</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">Geek_faf1c5</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">1</span></a></div>
                            </div>
                            <div class="bd comment-content">老师您好：<br>cpu缓存导致的可见性  cpu运行的单位是线程 而每个线程有本地内存 因为有线程本地内存的存在 也会导致可见性问题  那么线程的本地内存和cpu缓存是一会事吗  有什么关联？？？？</div>
                            <span class="time">2019-03-08</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">网上是有这么说法，你可以理解为cpu缓存和线程本地内存是一回事。但是我没有找到线程本地内存的官方出处。不敢人云亦云，所以专栏里就没有用这个概念。如果你感兴趣，可以找找。</p>
                                <p class="reply-time">2019-03-08</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/0f/96/63/fdbf75eb.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">捞鱼的搬砖奇</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">1</span></a></div>
                            </div>
                            <div class="bd comment-content">VolatileExample的意思是因为v是volatile的，所以读取的时候要从主内存拿，这个时候CPU缓存不会有其他变量了吗</div>
                            <span class="time">2019-03-06</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">没太明白你的问题。只是在说hb的事情。volatile不仅是禁用缓存，要综合hb规则来看<br></p>
                                <p class="reply-time">2019-03-06</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/10/d9/b6/4c498c17.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">1620</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">1</span></a></div>
                            </div>
                            <div class="bd comment-content">x=42 这个例子非常好 很炫  有一种追小说的感觉了 😄</div>
                            <span class="time">2019-03-05</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">早知道我去写小说了</p>
                                <p class="reply-time">2019-03-05</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epY7qGk5GXlibDY3f88RsZZUicUaLuiaIXfIGiczS54kD1hNobYWxcCFHCyiaEru9wpcWuI9WcBB7oNRfA/132" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">zyl</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">1</span></a></div>
                            </div>
                            <div class="bd comment-content">底层都是加store屏障 load屏障来保障可见性，立即从写缓冲区刷新数据到cache或主内存，立即重新read数据，写缓冲区没刷新触发写缓冲区刷新，拉取新数据。<br>加acquire和release屏障来禁止重排序</div>
                            <span class="time">2019-03-05</span>
                            
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/13/db/26/54f2c164.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">靠人品去赢</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">1</span></a></div>
                            </div>
                            <div class="bd comment-content">思考题线程修改后对后续线程可见，我只想到了synchronized关键字，Thread的start( )和join( )使用，没想到评论区人才这么多，方法可以这么多。<br>看完文章感觉对volatile，synchronized和final关键字有了新的了解，<br>首先volatile关键字是禁用缓存（CPU里面那个），保证的是从内存读取，要注意旧版本的线程可见性导致读取结果不正确。<br>synchronized关键字是关于锁，相当于用上就加锁对应的代码块结束就解锁，解锁后，后面的的线程就可以看到之前的内容。<br>final是要注意编译优化双重检查带来的问题（看文档，跟懒汉模式有关），不要想新他真的“生而不变”。</div>
                            <span class="time">2019-03-05</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">高手在民间</p>
                                <p class="reply-time">2019-03-05</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/10/d8/d6/47da34bf.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">任鹏斌</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">1</span></a></div>
                            </div>
                            <div class="bd comment-content">老师有个问题是关于A happen before B的判断，在第一个例子中x与v虽然一个在前一个在后，但并没有直接关联，仅仅是根据代码的前后就能判断happen before吗？如果v不加volati修饰又是如何呢？<br>// 以下代码来源于【参考 1】<br>class VolatileExample {<br>  int x = 0;<br>  volatile boolean v = false;<br>  public void writer() {<br>    x = 42;<br>    v = true;<br>  }<br>  public void reader() {<br>    if (v == true) {<br>      // 这里 x 会是多少呢？<br>    }<br>  }<br>}<br></div>
                            <span class="time">2019-03-05</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">如果不加 volatile，在单线程里<br> x = 42;<br> v = true;<br> if (v==true) { <br>    //这里x一定===42<br> }<br><br>多线程里没办法确定x是0还是42<br></p>
                                <p class="reply-time">2019-03-05</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/13/77/6f/454951d2.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">Lyre</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">1</span></a></div>
                            </div>
                            <div class="bd comment-content">老师 更新的有点慢 哈哈哈</div>
                            <span class="time">2019-03-04</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">这算不算饥饿营销?</p>
                                <p class="reply-time">2019-03-04</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/0f/73/4f/abb7bfe3.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">沙漠里的骆驼</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">1</span></a></div>
                            </div>
                            <div class="bd comment-content">请教一个问题，使用volatile关键字能解决上一节课中的双重检查问题吗？<br>我的理解是: volatile 本身的语义是禁用缓存，只有结合happens-before规整才有禁用重排序的意义。而对于双重检查的问题，对于变量本身的初始化，里面的语句的重排序是不会禁用的，因此解决不了双重检查的问题。<br>不过我看老师给的链接资料(http://ifeve.com/jmm-faq-dcl/)里面说是可以解决的，希望老师能够分析下；<br></div>
                            <span class="time">2019-03-04</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">能解决。<br>当你用happens-before规则来推算程序运行结果时，是站在Java语言的角度的。里面的语句和赋值语句是 顺序规则保证，顺序规则+传递+volatile 就能推算出来：能够解决。</p>
                                <p class="reply-time">2019-03-04</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/0f/49/85/3f161d95.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">Alpha</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">1</span></a></div>
                            </div>
                            <div class="bd comment-content">老师，第一条程序的顺序性规则 与 乱序执行是什么关系呢？<br>比如例子中第6行 `x = 42` happens-before 第7行 `v = true`，但是编译器有可能调整这两行语句的执行顺序的呀，这看起来是和这条happens-before规则冲突呢？希望老师能解答我的疑惑。<br></div>
                            <span class="time">2019-03-02</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">编译器可以调整顺序，但是要满足所有的happens before规则，如果冲突了，就是编译器优化错了。<br></p>
                                <p class="reply-time">2019-03-03</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/0f/48/bd/6c7d4230.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">Tony Du</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">1</span></a></div>
                            </div>
                            <div class="bd comment-content">这篇让我对volatile的理解茅塞顿开，感谢！</div>
                            <span class="time">2019-03-02</span>
                            
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/11/ac/ef/8336bd81.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">crazypokerk</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">1</span></a></div>
                            </div>
                            <div class="bd comment-content">请问老师，逸出指的是对象逃逸吗？</div>
                            <span class="time">2019-03-02</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">可以这么理解，不过和JVM的优化没关系</p>
                                <p class="reply-time">2019-03-02</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/11/29/9e/380a01ea.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">tracer</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">1</span></a></div>
                            </div>
                            <div class="bd comment-content">提一个可能比较幼稚的问题，参考1中的代码，volatile能保证不被重排序，但是volatile只修饰了v，意思是代码块中只要有一个volatile，代码块中都不会被重排序？<br>volatile变量规则说写操作对读操作可见，v是有初始值的，线程b先读v不可以吗？那如果线程a中多次修改了v的值呢？</div>
                            <span class="time">2019-03-02</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">代码块中有volatile，也挡不住被重排。但是重排后的结果一定符合happens-before规则。<br>b先读v可以啊，只是这个时候v==false</p>
                                <p class="reply-time">2019-03-02</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/10/fb/7b/7006a759.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">Jialin</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">1</span></a></div>
                            </div>
                            <div class="bd comment-content">我主要从共享变量的状态(是否可以被修改)进行思考它在多线程环境下的可见性问题，如果一个变量仅仅只是可读，那么它本身不会存在线程不安全问题，使用final进行修饰；如果一个共享变量可读可写，那么就使用synchronized和volatile来保证它在多线程环境下的可见性。</div>
                            <span class="time">2019-03-02</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">是这样!</p>
                                <p class="reply-time">2019-03-02</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/13/a8/38/6a714398.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">相民</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">1</span></a></div>
                            </div>
                            <div class="bd comment-content">@何方妖孽 JAVA8引入的Lambda语法</div>
                            <span class="time">2019-03-02</span>
                            
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/14/38/f1/996a070d.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">LW</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">1</span></a></div>
                            </div>
                            <div class="bd comment-content">传递性规则是讲解让我茅塞顿开</div>
                            <span class="time">2019-03-02</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">看你这么说，我心情大好。</p>
                                <p class="reply-time">2019-03-02</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/11/30/8a/b5ca7286.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">业余草</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">@Junzi 是个好问题，write() 方法内不会进行重排序。volitile只是说 对他的读会从主内存读取，而不会缓存拿，另一个作用就是加内存屏障，防止重排。</div>
                            <span class="time">2019-05-21</span>
                            
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/14/b5/ff/d1f205b0.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">L</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content"><br>Happens-Before 并不是说前面一个操作发生在后续操作的前面，<br>它真正要表达的是：前面一个操作的结果对后续操作是可见的。<br><br><br>Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法。<br><br><br>这是说一点我自己的理解：既然 JVM 需要遵循 JVM内存模型 的 Happens-Before 规则！！！<br> <br> 那么我大致推导一下：<br> <br> 假如现在只有A、B两个操作，那么 JVM 可能只需遵守 Happens-Before 规则1、2                  ---&gt; 此时称为 编译优化1<br> <br> 而假如现在有A、B、C三个操作，那么 JVM 可能就需遵守 Happens-Before 规则1、2、3、4          ---&gt; 此时称为 编译优化2<br> <br> 那么，这里的 编译优化1 就可能 == 编译优化2，也可能 !=编译优化2  ！！！<br> <br> 这样，我觉得就全部都通了！！！<br><br>不知道以上理解对不对？？？</div>
                            <span class="time">2019-05-19</span>
                            
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">Geek_477adb</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">按需禁用缓存，这里的缓存是指高速缓存，所谓禁用缓存是指CPU在进行运算前将数据加载到数据寄存器的时候，跳过高速缓存而直接去内存（不是JMM中的主内存）中查找么</div>
                            <span class="time">2019-05-15</span>
                            
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/12/00/15/6e399ec7.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">彭锐</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">理解了JMM，但为什么C/C++语言没有内存模型的说法？我已经想了几个原因：<br>1. C是编译型的，直接操作操作系统接口，pthread，直接用操作系统的能力解决问题，而Java定义的Thread对象，在操作系统之上加了一层；<br>2. C语言一定也有可见性和原子性问题，但不会这么冲出，因为Java是面向对象的，对象都是堆的，堆的都是共享的；如本文的例子，用C写都是栈内存；<br>3. C编译优化没有那么多诡异的重排；</div>
                            <span class="time">2019-05-14</span>
                            
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/15/e6/02/65a764fe.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">Michael</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">老师，本节所说的volatile修饰的变量禁止使用cpu缓存，那么上节课中的示例代码count用 volatile修饰，为什么运行的结果还是不正确?<br>public class Test {<br><br>  private volatile int count = 0;<br><br>  private void add() {<br>    int idx = 0;<br>    while (idx++ &lt; 10000000) {<br>      count += 1;<br>    }<br>  }<br><br>  public static int calc() throws Exception {<br>    final Test test = new Test();<br>    Thread th1 = new Thread(() -&gt; {<br>      test.add();<br>    });<br>    Thread th2 = new Thread(() -&gt; {<br>      test.add();<br>    });<br><br>    th1.start();<br>    th2.start();<br>    th1.join();<br>    th2.join();<br>    return test.count;<br>  }<br><br>  public static void main(String[] args) throws Exception {<br>    long c = calc();<br>    System.out.println(c);<br>  }<br>}</div>
                            <span class="time">2019-05-13</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">不能保证count+=1的原子性</p>
                                <p class="reply-time">2019-05-13</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/11/65/b0/9d11054a.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">smarttime</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">为什么会有问题，能不能再详细分析一下，就算我们的语言随意，请老师能否再自己细致讲解一下，看到那么多理解的不同的留言有些甚至还有矛盾，好揪心</div>
                            <span class="time">2019-05-11</span>
                            
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/11/65/b0/9d11054a.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">smarttime</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">我也想问例子中v不加volatile，读到x是多少？HB规则一到底该咋理解？老师这篇文章我读了5遍，在多线程环境下我还是不清楚该咋理解</div>
                            <span class="time">2019-05-11</span>
                            
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/0f/a0/57/2cf004c7.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">啊志聪啊</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">final是不变的,所以用final 修饰abc修改为其他值编译都不通过吧?还是意思abc是某实例的成员变量,final修饰这个实例对象?然后修改实例对象的abc属性为其他值,另外的线程就可见的了?</div>
                            <span class="time">2019-04-28</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">我觉得应该是：<br>final修饰这个实例对象，然后修改实例对象的abc属性为其他值,另外的线程就不可见了。</p>
                                <p class="reply-time">2019-04-28</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/10/cb/6f/c78ef1cf.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">王二北</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">"分析一下，为什么 1.5 以前的版本会出现 x = 0 的情况呢？我相信你一定想到了，变量 x 可能被 CPU 缓存而导致可见性问题。”， 这句话是不是有问题，线程B读取到变量x为0，不是因为cpu缓存导致的可见性问题，而应该是 指令重排导致的。</div>
                            <span class="time">2019-04-27</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">你说的是对的！！！</p>
                                <p class="reply-time">2019-04-28</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/11/50/1c/26dc1927.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">次郎</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">老师，happed befor规则必须要记住吗？不好背啊</div>
                            <span class="time">2019-04-26</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">不用背，用到了查一下就可以了</p>
                                <p class="reply-time">2019-04-28</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="http://thirdwx.qlogo.cn/mmopen/vi_32/LPnuO9GleKEwso2rSbibmbEwn49hnGl9qTQDBv2xLOOWOflQsc9oVEEuZgNBt7TrqRKvk8CX7Tc8iakhEicBCCfFg/132" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">盛权_vinc</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">老师，在write和read的例子中，如果boolean v没有用volatile修饰，是不是线程A、B就不会遵循happens-before规则？在write中x=42和v=true的执行顺序就可能会由于编译优化而重排，是这样吗？如果是，那是不是说happens-before规则第一条，顺序执行其实也是由volatile限制？我在网上看到提及volatile的特性都是:1,禁用线程本地缓存，直接在内存中读写;2,禁止指令重排。<br>而happens-before把这两个特性分成两个规则说明，是这么理解吗？</div>
                            <span class="time">2019-04-19</span>
                            
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/0f/ae/00/025f37e7.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">xuery</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">留言质量一级棒，参考留言和问题一个规则一个规则对照着看很有感觉：<br>1. 采用volatile变量修饰，根据hb规则2可以知道<br>2. 对abc=3的赋值操作加锁，之后其他线程对abc的访问加锁；根据规则4可以知道<br>3. 将设置abc的值为3的线程作为作为主线程，设置完abc=3之后在里面开启一个子线程B并start, 在子线程B里面访问abc,参考规则5<br>4. 将设置abc的值为3的线程作为子线程A，然后在B中调用A.join(),等join返回后再查看abc的值，参考规则6<br><br>对于3,4如果发生设置值的操作和start/join的操作指令重排，可能不一定能得到我们想要的结果！不知道理解的对不对？</div>
                            <span class="time">2019-04-18</span>
                            
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/13/38/69/864569a4.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">devil</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">规则1和volatile有什么关系？有volatile 变量才会遵循这个规则吗？如果例子中没有volatile是不是就不遵循顺序规则了</div>
                            <span class="time">2019-04-16</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">加上传递性就有关系了<br></p>
                                <p class="reply-time">2019-04-17</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">笨蛋</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">@发条橙子 。有点疑问：第四条规则。synchronized同步的代码块在释放锁的时候不是已经将abc的值更新到主内存中去了吗？其他线程再去获取这个值的时候不是已经是最新值了吗？</div>
                            <span class="time">2019-04-16</span>
                            
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">null</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">老师，您好。有两个问题没太理解<br>问题一： <br>“程序的顺序性规则”描述的是单线程内，按照程序的书写顺序，前面操作的结果对后续的任意操作可见。即单线程内，第 6 行代码“x = 42;”Happens-Before 于第 7 行代码 “v = true;”。多线程情况下，有可能发生重排，将“v=true;”排到了“x=42;”之前。我们都是在多线程的情况下讨论可见性问题，因此不太理解这条规则的作用。是配合 volatile 规则来使用的么？例如：<br>```<br>int a;<br>int b;<br>volatile int c;<br>int d;<br>int e;<br>```<br>a 和 b 不会重排到 c 的后面（而 b 有可能重排到 a 的前面），同样 d 和 e 不会重排到 c 的前面。<br><br>问题二：<br>之前在留言里提问：<br>&gt;@发条橙子… 的思考题分析，有些不太准确吧，例如评论里指出的程序顺序性。还有 synchronized 的分析也不太准确吧，synchronized(abc) 可能保证后续操作可见。<br>&gt;<br>&gt;作者回复: synchronized 的分析没有问题，其他线程直接访问还可能不是最新值，我理解直接就是没有使用任何同步手段。<br>&gt;即便用 synchronized，用法不对，也达不到效果。<br><br>上述提问“还有 synchronized 的分析也不太准确吧”，不是对文章中的 synchronized 的分析表示疑惑，而是@发条橙子… 的分析有疑惑：<br>&gt;4. 第四条规则， 使用管程，由于是访问共享变量，如果是在syn中修改值只能保证当前线程下一次进入syn可以看见最新的值，其他线程直接访问还可能不是最新值 ， 不行<br><br>自己的理解是：<br>synchronized(abc) 是可以保证后续其他线程的操作能够看到 abc 写操作的结果的，即可以看到 abc 的最新值。不知道理解是否正确。<br><br>谢谢老师！！</div>
                            <span class="time">2019-04-14</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">1. 是这样，规则1必须和传递性还有其他规则结合，才有作用<br>2. 我说的也是@发条橙子的分析没有问题，按照hb规则，读写必须都用synchronized才能确保没有问题。@发条橙子说的“直接”，我理解就是没有使用任何同步手段。<br><br>“synchronized(abc) 是可以保证后续其他线程的操作能够看到 abc 写操作的结果的。”这个根据hb规则是推断不出来的。所以你看早期Vector的实现，所有读操作也都用synchronized修饰，哪怕是size()就返回一个elementCount。这个和abc的问题是一样一样的。</p>
                                <p class="reply-time">2019-04-14</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/11/8a/16/10420350.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">LouisLimTJ</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">王老师你好，我有个关于happen before的第一条规则。你说到前面的操作可见于后面的操作。对于，可见于之后的操作，是指对于volatile变量的操作呢， 还是什么变量都是？ 如果是后者，那岂不是意味着Java完全禁止了reorder的编译优化了？</div>
                            <span class="time">2019-04-14</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">规则1仅仅对单线程有效。没有全部禁止。</p>
                                <p class="reply-time">2019-04-14</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">玉树临枫</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">掌握Java内存模型很重要，特别是里面的一些关键字和一些规则，需着重理解。下面是我对volatile 关键字的理解和总结，欢迎各位参考<br>https://www.cnblogs.com/yuanfy008/p/9335168.html</div>
                            <span class="time">2019-04-13</span>
                            
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/16/03/09/74acf5ca.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">云外有云</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">老师，这段代码出现了死锁，但我还是没整明白，帮忙指点一下，谢谢<br><br>锁都是静态object<br><br> public static T GetClient&lt;T&gt;(int clientTimeout = 3, int retryCount = 1, int retryBreak = 1)         {<br><br>            if (isRunOne)<br>            {<br>                lock (m_initlock)<br>                {<br>                    if (isRunOne)<br>                    {<br>                        MicroClientInit(clientDllPath);<br><br>                        if (!ClientDllPathList.Contains(clientDllPath))<br>                        {<br>                            ClientDllPathList.Add(clientDllPath);<br>                        }<br><br>                        isRunOne = false;<br>                    }<br>                }<br>            }<br><br>            if (!ClientDllPathList.Contains(clientDllPath))<br>            {<br>                lock (m_initlock)<br>                {<br>                    if (!ClientDllPathList.Contains(clientDllPath))<br>                    {<br>                        ConsulHelper.Instance.AppendService(clientDllPath);<br>                        ClientDllPathList.Add(clientDllPath);<br>                    }<br>                }<br>            }<br>}</div>
                            <span class="time">2019-04-12</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">出现死锁的时候，把线程栈dump出来，就能知道原因了<br></p>
                                <p class="reply-time">2019-04-12</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/10/15/03/c0fe1dbf.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">赤城</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">感谢老师的讲解，也感谢首评Handongyang的评论，把java对难懂的happens-before讲的这么透彻！</div>
                            <span class="time">2019-04-11</span>
                            
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/10/3e/01/9bb11f13.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">whyoyyx</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">@胡桥，我把你的sleep(1) ，改成其他耗时计算就能复现。不过在试验之前先保存好相关文件。</div>
                            <span class="time">2019-04-10</span>
                            
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/12/52/78/4365471c.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">Forever</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">老师 @Handongyang 说当一个对象包含final修饰的实例字段时，其他线程能够看到已经初始化的final实例字段，这是安全的。 那么是否可以理解为思考题中的abc如果设置为final修饰，他也可以被其他的线程看到？</div>
                            <span class="time">2019-04-05</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">可以<br></p>
                                <p class="reply-time">2019-04-05</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/15/fe/b4/6902ac00.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">王成</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">普通读写+普通读写 允许指令重排<br>普通读写+volatile读 允许<br>普通读写+volatile写 不允许<br>volatile读+任何 不允许<br>volatile写+普通读写 允许<br>volatile写+volatile读写 不允许<br>希望大家指导</div>
                            <span class="time">2019-04-03</span>
                            
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/12/03/c9/9a9d82ab.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">涛哥</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">最后那个逸出是不是因为指令重排序导致this赋值操作可能第一个执行，这个时候x还没有赋值，所有可能访问到x=0</div>
                            <span class="time">2019-04-02</span>
                            
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/12/b5/d4/3bd5b77b.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">佑儿</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">老师，你好，重读本章有一个疑问，看过一篇jmm的文章，写到jmm定义了线程和主内存之间的抽象关系，具体如下：共享变量存储于主内存中，线程共享；每个线程都有私有的工作内存；工作内存只存储该线程对共享变量的副本，线程不能直接操作主内存，我的疑问是既然每个线程都有私有的本地内存，那为什么前面一章描述单核cpu不存在可见性问题呢？ </div>
                            <span class="time">2019-04-01</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">工作内存不是物理存在的，别把它当回事<br></p>
                                <p class="reply-time">2019-04-01</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/0f/a3/8b/080d337e.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">燕青兄弟</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">1：可以在abc这个变量前面，加入volatile修饰符；<br>2：可以在abc=3这个语句后面，执行一个被volatile关键字修饰的变量赋值操作；<br>3：可以在abc=3这行代码前后加入synchronized关键字，保证其可见性；<br></div>
                            <span class="time">2019-04-01</span>
                            
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/10/cb/6b/acaa5d89.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">w w</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">这个课程很好，把以前只能看懂字读不懂的知识都串起来了，形成体系化，连测试都读懂了，赞啊</div>
                            <span class="time">2019-03-26</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">说明测试水平也不低😄<br></p>
                                <p class="reply-time">2019-03-27</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/11/52/37/13b4c8aa.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">Vincent</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">管程中的锁规则只对synchronized 这个锁有效？</div>
                            <span class="time">2019-03-25</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">是</p>
                                <p class="reply-time">2019-03-25</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/10/ce/ab/e9d7811f.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">shawn</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">实在忍不住要来讲几句，老师的课程讲得真的很精彩，受益匪浅。</div>
                            <span class="time">2019-03-22</span>
                            
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/10/bd/18/669ba15f.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">兔2🐰🍃</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">一楼所说的"（6）.线程中断规则：对线程<br>interrupt()方法的调用先行发生于被中<br>断线程的代码检测到中断事件的发生，<br>可以通过Thread.interrupted(）方法检测<br>到是否有中断发生。"<br>对于这个不是很好理解，可以举个例子说明下么，谢谢</div>
                            <span class="time">2019-03-22</span>
                            
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/10/32/dc/d3e3847f.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">江南豆沙包</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">老师，有个疑问，有没有可能多个线程在同一时间给volatile修饰的变量赋值，那样最终的值是不是就不确定了？</div>
                            <span class="time">2019-03-21</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">后面的会覆盖前面的</p>
                                <p class="reply-time">2019-03-22</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/11/29/9e/380a01ea.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">tracer</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">测试重排序可以使用OpenJDK CodeTools 项目的jcstress 工具, 详细见极客时间深入拆解虚拟机13讲和https://wiki.openjdk.java.net/display/CodeTools/jcstress</div>
                            <span class="time">2019-03-20</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">厉害👍<br></p>
                                <p class="reply-time">2019-03-20</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/11/d4/a1/8bc8e7e1.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">赌神很低调</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">abc定义为volatil变量，写操作定义在同步块中，读线程join写线程</div>
                            <span class="time">2019-03-19</span>
                            
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/10/66/75/54bb858e.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">life is short, enjoy more.</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">好记性不如烂笔头，我是这么理解这篇文章的<br>有序性的保证，是hb原则约束优化的结果。<br>可见性的保证，是被volatile关键字修饰的变量的读操作，会导致其他cpu cache中的变量失效，需要从内存中重新load的结果。</div>
                            <span class="time">2019-03-19</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">我不敢揣测jvm和cpu起如何实现，只要能够用hb推断可见性就够了</p>
                                <p class="reply-time">2019-03-19</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/12/4f/d5/e23dc965.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">Felix Envy</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">老师你好，基于happen-before规则，是不是可以理解在jdk1.5之后，双检锁不会再有问题？</div>
                            <span class="time">2019-03-19</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">还是有问题，加volatile可以解决，详细方法可以搜索网文<br></p>
                                <p class="reply-time">2019-03-20</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/12/a4/3c/121e7f9f.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">xiyuesmiling</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">1.5之后，如果有规则一，为什么还会导致变异优化导致的读取变量x不对呢？</div>
                            <span class="time">2019-03-19</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">规则一仅仅适用单线程<br></p>
                                <p class="reply-time">2019-03-19</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/10/e0/24/4529f2a4.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">WP</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">优秀，很增长知识</div>
                            <span class="time">2019-03-19</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">看完你也优秀👍</p>
                                <p class="reply-time">2019-03-19</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/11/15/69/fc60d1f4.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">陈华应</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">1、直接使用volatile修饰abc，根据happens-before 对volatile的写happens-before于后续对这个变量的读<br>2、使用volatile修饰控制访问abc的标示，并且在修改abc=3之后将访问标示设置为true，在后续访问abc代码处先判断是否可访问abc，根据happens-before 程序有效性和对volatile语义增强，可保证在访问abc标示为true的时候访问abc一定是3<br>3、对abc=3操作加锁，管程中的锁，解锁happens-before于加锁<br>4、主线程设置abc=3，然后调用子线程的start()方法启动子线程，子线程可见abc=3<br>5、子线程设置abc=3，然后启动子线程，并调用子线程的join方法，子线程abc=3对主线程可见<br>感觉老师这题就是用来回顾本章内容的，不知道是否正确？</div>
                            <span class="time">2019-03-18</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">很全面了</p>
                                <p class="reply-time">2019-03-19</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/13/c2/d5/126eac1a.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">宝石山</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">老师关于HB的第四条管程中锁的规则，适用于ReentrantLock吗？</div>
                            <span class="time">2019-03-18</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">不适用，后面介绍并发包的时候会说这个问题<br></p>
                                <p class="reply-time">2019-03-18</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/10/66/75/54bb858e.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">life is short, enjoy more.</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">新学生对本门课程的第一次留言~<br>// 以下代码来源于【参考 1】<br>final int x;<br>// 错误的构造函数<br>public FinalFieldExample() { <br>  x = 3;<br>  y = 4;<br>  // 此处就是讲 this 逸出，<br>  global.obj = this;<br>}<br><br>老师你好，这个例子我不是很理解，看到你给其他同学的答复是，this可能没有初始化完。但是这不就是一个构造函数吗，this位于构造函数的最后一行，而且x已经赋值了，为什么可能存在其他线程读到x==0的情况呢？</div>
                            <span class="time">2019-03-18</span>
                            
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/10/66/75/54bb858e.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">life is short, enjoy more.</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">新学生对本门课程的第一次留言~<br>// 以下代码来源于【参考 1】<br>final int x;<br>// 错误的构造函数<br>public FinalFieldExample() { <br>  x = 3;<br>  y = 4;<br>  // 此处就是讲 this 逸出，<br>  global.obj = this;<br>}<br><br>老师你好，这个例子我不是很理解，看到你给其他同学的答复是，this可能没有初始化完。但是这不就是一个构造函数吗，this位于构造函数的最后一行，而且x已经赋值了，为什么可能存在其他线程读到x==0的情况呢？</div>
                            <span class="time">2019-03-18</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">指令可能会重排，把x=3排到后面<br></p>
                                <p class="reply-time">2019-03-18</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/15/dd/8d/0396fabe.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">math</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">@junzi:我的理解是，关于第一条程序顺序执行确实发生在单线程中，编译器确实有可能对其进行重排，但是老师说1.5及以后引入happen-before规则可以确定对volitole变量的写对后面该变量的读可见。所以这时候要满足传递性。就不能发生重排</div>
                            <span class="time">2019-03-15</span>
                            
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/10/11/9c/87ced1de.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">白了少年头</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">老师我对思考题有个疑问啊，前面有个同学回答有三种办法，其中第二种是：“声明共享变量abc，在synchronized关键字对abc的赋值代码块加锁，由于Happen-before管程锁的规则，可以使得后续的线程可以看到abc的值”，老师回复是三种方式都正确。我的疑问就是，如果只对abc的赋值代码块同步的话，如果有一个getabc()方法，该方法并没有用synchronized修饰，其他线程在调用该方法获取的abc的值，是不是有可能不等于3呢？</div>
                            <span class="time">2019-03-13</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">读写都要加同步块<br></p>
                                <p class="reply-time">2019-03-13</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/16/1c/d5/248a9c38.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">你只是看起来很努力</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">老师，看完你给WL同学解答逸出，终于明白了为什么静态方法中不能使用this了，没有初始化，也就没有这个对象。</div>
                            <span class="time">2019-03-13</span>
                            
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/10/94/47/75875257.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">虎虎❤️</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">思考题：可以利用各种happens-before 规则；或者间接的使用传递性来保证其他线程可见。</div>
                            <span class="time">2019-03-13</span>
                            
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/10/94/47/75875257.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">虎虎❤️</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">对于规则5，依据我对线程启动的理解，自线程b应该在创建之时 拷贝所以线程a的栈。所以规则5是不是线程创建后自然而然的就满足了这个规则？<br><br>我的理解对吗，还是说有其他的机制来保证？</div>
                            <span class="time">2019-03-13</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">没那么简单，线程栈里都是不共享的数据，天生就安全，问题出在共享变量上<br></p>
                                <p class="reply-time">2019-03-13</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/10/94/47/75875257.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">虎虎❤️</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">规则4 是需要 结合规则1，3 来理解的。<br>因为规则1 对x的操作的happens-before 解锁，<br>因为规则4 解锁happens-before其他管程的加锁。<br>因为规则3 对x的操作 happens-before 其他管程的加锁。<br><br>那么问题来了，什么情况下触发规则1呢？结合课程所讲，应该是按需的限制缓存和编译优化。所以是在有volatile 或者 synchronized 关键字的时候触发规则1吗？还有没有其他的情况？</div>
                            <span class="time">2019-03-13</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">规则一在单线程永远成，不需要触发<br></p>
                                <p class="reply-time">2019-03-13</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/10/94/47/75875257.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">虎虎❤️</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">王老师，您好。文中提到了规则3是1.5以后对volatile的强化。<br><br>但是根据规则1 x=42的赋值一定发生在v=true赋值之前 和 规则2 线程b的读（后续读）一定发生在线程a对变量v的写之后。 那么自然而然的，x=42的写不就一定发生在线程b读x之前了吗？为什么说规则3是1.5的强化，并且有了规则3，就避免读到x=0呢？或者说，有了1，2不就一定保证了3的发生吗？<br><br>在描述这个问题的过程中，我已经自己想到了答案。记录下来供和我有（if have）同样疑惑的同学，或者以后的自己参考把。<br><br>我的理解是：这里还是需要从内存的可见性来分析。<br>规则1 保证了在线程A的cpu缓存中，x=42一定发生在写入v=true之前。<br>规则2 保证了在线程B在读取v这个变量之前，一定是先确保了其他cpu缓存中的v flush到内存中了，并且把v的值同步到自己的缓存里。也就是如果其他线程在此之前写过变量v，那么此时线程B在读v的时候，一定是能看到之前其他线程写v的结果。<br>规则3 的传递性则保证了，在线程B读v之前，线程A对x的写操作对线程B一定可见。其实就是保证把线程A中cpu缓存的x值同步到线程B的cpu缓存中。<br>结论：只有单核的情况下，1，2才能保证3。</div>
                            <span class="time">2019-03-13</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">规则1只适用到线程，别考虑缓存以及怎么实现的，先理解需求，才能把代码写好，先读懂规范，再来想实现，两者别搞混了。实现没有咱们想的那么简单<br><br></p>
                                <p class="reply-time">2019-03-13</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/11/af/45/8bacada2.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">你说的灰</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">参考1中write()方法代码：<br>x=45; // 1<br>v=true; // 2<br>这两行会不会导致指令重排？<br><br>因为volatile关键字应该只保证了变量v的可见性，happen-before第一条原则在单线程中，1与2重排并不影响结果，那应该有可能出现重排的情况，这样线程B读取到read()的时候也有可能出现x=0。还请老师解答。<br><br>同问，望解答</div>
                            <span class="time">2019-03-12</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">线程1里执行这两行，线程2里执行读。<br>线程1用规则1，线程 2用vo规则，再加上传递性。<br><br>就有结果了，jvm一定要保证遵守规则，所以不会出现你想的问题。</p>
                                <p class="reply-time">2019-03-13</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/11/52/37/13b4c8aa.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">Vincent</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">老师为什么volatile可以保证对他之后的变量修改操作的可见性？happen-before没有这项规则啊</div>
                            <span class="time">2019-03-12</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">没有，哪里说保证这个了？</p>
                                <p class="reply-time">2019-03-12</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/11/af/45/8bacada2.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">你说的灰</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">同问</div>
                            <span class="time">2019-03-12</span>
                            
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/12/82/2c/e8cf7f2f.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">若尘</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">既然引出了内存模型及happen before原则，那jdk中又是如何保证这些原则的呢？或者说怎么实现了这些原则？谢谢</div>
                            <span class="time">2019-03-12</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">没写过jvm的编译器和解释器，不敢妄谈，你如果感兴趣可以研读一下jsr133 的后半部分，那个是面向jvm的实现人员的<br></p>
                                <p class="reply-time">2019-03-12</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/0f/96/63/fdbf75eb.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">捞鱼的搬砖奇</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">这里关于final的不是很懂，能不能再说明确点。</div>
                            <span class="time">2019-03-12</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">就是一旦赋值，就不再变化，线程安全。</p>
                                <p class="reply-time">2019-03-12</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/16/26/95/a4e0f7ab.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">龙哥</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">关于课程<br>虽说是音频，感觉比视频更有画面感。相关的视频也看过，只是交如何使用，但是没讲原理，讲完就忘。这个课程从原理给大家梳理知识，感觉课程特别赞<br><br>关于思考题<br>1.可以设置abc变量为volatile,那么线程A对abc的写操作都会Happens-before后续线程<br>2.使用synchronized,每次操作时都会加锁，保证每次只有一个线程对abc进行改变，使得其他线程都能正确读到该值<br>3.使用join，线程A改变了abc后，b线程等待A线程完成，A线程对共享变量abc的操作都happens-before后续线程<br></div>
                            <span class="time">2019-03-10</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">感谢盛赞<br></p>
                                <p class="reply-time">2019-03-11</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/11/55/96/5160cd31.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">阿甘</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">class VolatileExample 中即使变量v不加volatile，由于X86CPU不支持写写重排序，在x86上面操作，这个一定会是x=42（从别的网页看到的，本人没有验证）</div>
                            <span class="time">2019-03-10</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">规范是一码事，具体实现是一码事。这个我也验证不出来，不过还是按照规范办事好些。</p>
                                <p class="reply-time">2019-03-10</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/11/08/1c/ef15e661.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username"> 臣馟飞扬</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">王老师讲解的happen-before规则甚好，之前以为A happen-before B就是A发生在B之前，这次有了新的认识。</div>
                            <span class="time">2019-03-10</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">多谢盛赞！！</p>
                                <p class="reply-time">2019-03-10</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">QQ怪</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">我是不是可以通过happen-before那几个规则能够推算出前面一个操作的结果对后续操作是可见性?</div>
                            <span class="time">2019-03-09</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">是这样，折腾半天其实就是解决这么个问题。你总结的太到位了！</p>
                                <p class="reply-time">2019-03-09</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/11/e9/0b/1171ac71.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">WL</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">我有一个问题,  cpu缓存和各个线程中缓存的主内存的本质复本是不是一回事? </div>
                            <span class="time">2019-03-09</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">我认为，各个线程中不会缓存主内存的副本。除非线程被挂起，才会把寄存器的内容复制到线程上下文里面。<br><br></p>
                                <p class="reply-time">2019-03-09</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/10/e2/a5/05276fad.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">马克</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">老师，有一点不明白：使用volatile关键字修饰的变量，在执行++操作的时候，有取值，计算，赋值的CPU指令，如果在时间分片到达时才执行了计算，此时会继续执行赋值操作再切换吗？同样的，像这种多CPU指令的操作加上synchronize后，中间指令发生切换时，是不是继续执行同步块内的代码？否则，是否会出现脏数据？<br>谢谢指导</div>
                            <span class="time">2019-03-08</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">操作系统随时都可以切换，不管线程执行到哪里。下一期会讲sync，不会有脏数据的<br></p>
                                <p class="reply-time">2019-03-08</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/12/72/bf/26519889.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">Owen</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">Thread B = new Thread(()-&gt;{<br>  // 主线程调用 B.start() 之前<br>  // 所有对共享变量的修改，此处皆可见<br>  // 此例中，var==77<br>});<br>// 此处对共享变量 var 修改<br>var = 77;<br>// 主线程启动子线程<br>B.start();<br><br>Thread B可以访问var是不是意味着主线程在启动Thread B之前要把主存设置为无效，并把var更新到主存?<br><br></div>
                            <span class="time">2019-03-08</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">这个我真不敢确定。做JVM的人远比我们聪明。</p>
                                <p class="reply-time">2019-03-08</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/12/72/bf/26519889.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">Owen</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">synchronized (this) { // 此处自动加锁<br>  // x 是共享变量, 初始值 =10<br>  if (this.x &lt; 12) {<br>    this.x = 12; <br>  }  <br>} // 此处自动解锁<br><br>Hi，老师我此处不太明白，<br>1.假设A线程进入同步块，执行了  this.x = 12，当自动解锁的时候会把12刷回主存吗？<br>2.按您文章中的说法，当线程B进入同步块的时候才可以访问到x=12，那jvm是如何做到这一点的，<br>3.那如果有一个线程C在进入同步块前拿到的x=10？还是12<br></div>
                            <span class="time">2019-03-08</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">是否刷缓存、以及jvm是如何做到是JVM的开发人员要考虑的。你可以参考一些内存屏障之类的东西，我工作中用不到，所以我也只是道听途说，就不敢误导大家了。我觉得更重要的是能利用这些规则，推演程序的执行过程。<br><br>线程C在进入同步块前，也许能看到10，也许能看到12，这个不确定。所以才需要同步。<br><br><br></p>
                                <p class="reply-time">2019-03-08</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/0f/76/23/31e5e984.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">空知</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">查了下,切换时事先开辟好的一块固定空间里，比如Linux的task_struct 来存线程信息</div>
                            <span class="time">2019-03-08</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">是这样的，linux里的线程就是用进程结构实现的<br></p>
                                <p class="reply-time">2019-03-08</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/14/40/ef/52bbadb9.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">那就这样吧</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">有种恍然大悟的感觉，之前也看过关于happen-before,但一直没能理解。</div>
                            <span class="time">2019-03-07</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">我曾经跟你一样</p>
                                <p class="reply-time">2019-03-07</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/13/47/39/cda2f2b3.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">木木匠</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">文中说到volatile 为的是禁用缓存，这里我个人觉得说法欠妥，volatile 主要的作用应该是当修饰的变量被修改了，会立即刷回主缓存，同时其他cpu缓存改变量会失效，需要重新从主缓存刷新变量的值。所以从这层面上说volatile 其实还是有用缓存，只是效果和禁用缓存一样。个人理解。</div>
                            <span class="time">2019-03-07</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">对于初学者，你的这个解释虽然正确，但是不好理解。volatile在1.5以后不仅仅是禁用缓存<br></p>
                                <p class="reply-time">2019-03-07</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/11/f9/a7/1e69b9a1.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">传葱</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">根据老师上面讲的规则，应该是存在6种情况的，happend-before除了第一种情况用于同一个线程之外。后面都可以处理多线程之间的可见性问题。第一个共享变量加上volatile。第二个传递性，除了这个共享变量abc之外，新建一个volitile变量ccc，在abc赋值之后写入ccc，另外一个线程在读取abc之前读取ccc。第三个，加锁，synchronized。第四个，start方法，一个线程必然是在start（）之后才会run的，start在主线程中又可以使用第一条顺序性规则。第五个，join，等待异步线程结束，其实和start差不对，原理基本相同。最后使用final，只能赋值一次，必然是不变的，声明为共享变量，控制一下赋值时间就行，这个体现的不明显。</div>
                            <span class="time">2019-03-07</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">太全面了！</p>
                                <p class="reply-time">2019-03-07</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/12/f8/ea/98738420.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">Jaswine</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">膝盖收下！！！</div>
                            <span class="time">2019-03-06</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">要是再多转发就更好了</p>
                                <p class="reply-time">2019-03-07</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/14/0d/58/008173ad.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">punchline</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">@狂战俄洛伊 有一点不是很明白 根据happens-before 规则第一条，在一个线程中，会按程序代码顺序 前面的代码块对于后面的代码块可见，那为什么int a =1与int b =2的执行顺序不一定呢？ 既然后面的int b =2 可以看见前面的int a=1 那int a=1 不是应该一直在int b=2的前面执行吗? </div>
                            <span class="time">2019-03-06</span>
                            
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKtS26SJpSF7JLu9pusGsy1Qln0NdQg1eV2YKOJxpX2QXaBuuyXMqZY3fm0rhzKwsqN5aa6CVNOQQ/132" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">陈华</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">老师有一个疑问:<br>第一个顺序性，第6,7行代码<br>x = 42; <br>v = true;<br>会不会被重新排序为<br>v = true;<br>x = 42；<br>这样A线程 执行完 v=true; 后，cpu切换到线程B，B此时读取的x值为0.<br><br>第6,7有重排序的可能吗，为啥呢？</div>
                            <span class="time">2019-03-06</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">这个只是个例子，实际编译器的优化和cpu执行的优化远不是我们想象的。这个例子只是告诉你编译器重排是不是合法，如果合法那就有可能，实际上可能不会。</p>
                                <p class="reply-time">2019-03-06</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoRiaKX0ulEibbbwM4xhjyMeza0Pyp7KO1mqvfJceiaM6ZNtGpXJibI6P2qHGwBP9GKwOt9LgHicHflBXw/132" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">Geek_ebda96</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">老师，你这个例子<br>// 以下代码来源于【参考 1】<br>class VolatileExample {<br>  int x = 0;<br>  volatile boolean v = false;<br>  public void writer() {<br>    x = 42;<br>    v = true;<br>  }<br>  public void reader() {<br>    if (v == true) {<br>      // 这里 x 会是多少呢？<br>    }<br>  }<br>}<br>就算不加volatile，启动两个线程，第一个线程writer(),第二个线程reader(),还是不会出现x=0的情况呀</div>
                            <span class="time">2019-03-06</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">这个只是告诉你理论上会出问题。实际上也许不会出。这个例子只是告诉你如何深入理解volatile</p>
                                <p class="reply-time">2019-03-06</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/13/18/f6/2ff7bc7a.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">轻歌赋</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">这里考虑的应该是读在写后面发生的情况下是否正确读到了abc的值，所以直接<br>final int abc = 123初始化是最简单的</div>
                            <span class="time">2019-03-06</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">是的</p>
                                <p class="reply-time">2019-03-06</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">Smallfly</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">令哥，我不是 Java 程序员，但是对文中的可见性问题有些疑惑。<br><br>上一讲说可见性问题是缓存导致的，我不确定可见性问题，是不是指导致 10000 + 10000 &lt; 20000 的问题。<br><br>因为即使没有 CPU 缓存，这个问题在多核中还是会存在的，比如线程 A 从内存读取变量 x = 0，进行 +1 操作，在写入内存前，线程 B 也读取 x，并做 +1 操作，当两个线程都写入时，x 的值只有 1。<br><br>这个是否属于可见性问题呢？如果不是，出现非预期结果就跟可见性问题没关系；但如果是，这又跟 CPU 缓存没什么关系。<br><br><br>还有这一讲中说 1.5 版本后 volatile 中加入 Happens-Before 规则，防止指令被编译器优化。个人觉得只要满足第一条“程序的顺序性规则”，即 x = 42 先于 v = true 执行，就不会出现 x = 0 的结果。规则 2 和规则 3 对这段代码来说没什么帮助，我不确定是不是会在其它场景有效。<br><br>指望老师能指点一二，感谢。<br></div>
                            <span class="time">2019-03-06</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">单线程里只有规则一是可以的。文中的例子多线程的场景。读写是两个线程的时候，没办法保证正确性。<br><br>即使没有 CPU 缓存，也会有问题。这个不属于可见性的问题，属于原子性的问题。</p>
                                <p class="reply-time">2019-03-06</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/13/0d/ac/09678490.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">谢特</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">可见性怎么定义的</div>
                            <span class="time">2019-03-06</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">写完后，别的线程能正确读出来</p>
                                <p class="reply-time">2019-03-06</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/11/29/9e/380a01ea.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">tracer</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">class VolatileExample {<br>  int x = 0;<br>  boolean v = false;<br>  public void writer() {<br>    x = 42;<br>    v = true;<br>  }<br><br>  public void reader() {<br>    if (v == true) {<br>         System.out.println(x);<br>    }<br>  }<br>}<br><br>老师的例子中我删除了volatile，但是并没有测试出输出v=0的情况，这是怎么一回事呢？</div>
                            <span class="time">2019-03-05</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">我也没测出来。因为这个代码编译器压根就没啥好优化的。这个例子只是用来分析问题的</p>
                                <p class="reply-time">2019-03-05</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/12/33/25/eac79a47.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">陈康康</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">不知道下面这段话怎么理解呢，不可变对象多线程之间还要使用同步（锁），这个没有理解，望回复<br>Now, having said all of this, if, after a thread constructs an immutable object (that is, an object that only contains final fields), you want to ensure that it is seen correctly by all of the other thread, you still typically need to use synchronization. There is no other way to ensure, for example, that the reference to the immutable object will be seen by the second thread.<br><br></div>
                            <span class="time">2019-03-05</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">final class A{}<br>A x = new A();<br><br>它上面这段的意思，应该是说x的事情。x不是final的，所以需要同步。</p>
                                <p class="reply-time">2019-03-05</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/0f/6a/e9/9d9d9e87.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">tom</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">我有一个问题一直弄不明白，volatile 禁用指令重排的边界如何确定？synchornzied 包裹的代码块有明确的边界，不管是否在临界区内的代码是否调用其他方法。<br><br>而对 volatile 类型变量前后的变量的操作并没有明确的语义上的边界？查了很多资料，仍然没有找到答案，希望老师解答一下。<br></div>
                            <span class="time">2019-03-04</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">别想禁用指令重排的事，就用顺序性规则+传递行规则+volatile规则来推断就可以了<br>边界就是只要给volatile赋值成功，那么这个赋值语句之前所有代码的执行结果都对其他线程可见<br></p>
                                <p class="reply-time">2019-03-05</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/10/32/0d/6e0a440f.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">M老立</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">王老师 什么时候上新啊 等不及了 这两天反复看已经有的 每一遍都有收获 </div>
                            <span class="time">2019-03-04</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">编辑回复</span></div>
                                <p class="reply-content">每周二四六</p>
                                <p class="reply-time">2019-03-04</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/11/2b/45/e8f64725.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">Smile</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">1. 对于程序的顺序性规则，针对的一个线程中，前面的操作对后面的操作可见，是不是可以理解为，代码重排之后，在前面执行CPU指令执行的结果对后面的执行结果是可见的。<br>2. 同样是对于顺序性规则，如果参考1中，没有加volatile关键字的话，x 和v的初始化很有可能重排，那么当多个线程访问时，就会出现当读的时候出现x=0的情况。volatile保证了修改变量之前的语句按照书写的顺序执行，不能进行排序。同时，保证了修饰变量的可见性。<br>3 对于volatile变量规则，写操作优于读操作，应该是写操作之后的数据会及时更新到内存，其他线程可见，或者理解为写操作优于后续时间对该变量的执行的写操作和读操作<br>不知道这些理解是否正确，请老师指正</div>
                            <span class="time">2019-03-04</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">对于volatile变量规则：从时间上，先写入的数据，后面查，一定能查的到。优于这个词我不太理解，感觉不太对。<br><br>这些规则得组合着看，才有意义。</p>
                                <p class="reply-time">2019-03-04</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoRiaKX0ulEibbbwM4xhjyMeza0Pyp7KO1mqvfJceiaM6ZNtGpXJibI6P2qHGwBP9GKwOt9LgHicHflBXw/132" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">Geek_ebda96</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">start原则对于非主线程的两个线程有效么，对同一共享变量的赋值顺序跟线程启动顺序有关系不</div>
                            <span class="time">2019-03-04</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">有效。当然有关系。</p>
                                <p class="reply-time">2019-03-04</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/13/0e/6c/3f179ea8.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">翟毅</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">思考题答案，volatile或者final</div>
                            <span class="time">2019-03-03</span>
                            
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erWxMXolPylQk8Z6V6yt2LtibksrksC4bHtmxkuCC4Wzw7trl6CfwmsSFMyHFItFnvl21RvQ8fyOBQ/132" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">Geek_961eed</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">希望作者，能够深入的讲解下final在并发环境下的应用，final这部分读起来感觉不是太通透，谢谢！</div>
                            <span class="time">2019-03-03</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">这部分final和我们正常的理解是一致的，只要保证不要“逸出”，就没问题。没坑，所以就没有详细介绍。</p>
                                <p class="reply-time">2019-03-03</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKwvj3wcI41yVmRjbiat3HmIwF73ib7UlKzSHeQuLeXcVYChHRO7gWtJ8kvpjpiaiciaFuQaZfsV9he4Iw/132" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">aksonic</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">Thread B = new Thread(()-&gt;{<br>  // 主线程调用 A.start() 之前<br>  // 所有对共享变量的修改，此处皆可见<br>  // 此例中，var==77<br>});<br>// 此处对共享变量 var 修改<br>var = 77;<br>// 主线程启动子线程<br>B.start();<br><br>老师，“主线程调用 A.start() 之前”是否写错了，应该是“主线程调用 B.start() 之前”，因为示例代码里面根本没有A。</div>
                            <span class="time">2019-03-03</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">的确是这样啊，多谢指正，回头我让小编改过来。</p>
                                <p class="reply-time">2019-03-03</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/15/f8/a1/8780f900.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">封万里</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">happens-before的第一个规则实际上禁止了指令重排序，可以这么理解吗？希望老师解答一下呢</div>
                            <span class="time">2019-03-03</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">没有禁止指令重排，要求编译器重排后的结果==顺序执行的结果。所以你可以用顺序执行来推断结果。</p>
                                <p class="reply-time">2019-03-03</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/13/f3/b1/0429aa3b.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">青冰白夜</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">老师问一个纠结的问题<br>如下事例代码假设是在单线程执行。<br>int i=0；//语句1<br>int j=0； //语句2<br>这里根据Happens-Before规则，单线程中语句1一定是比语句2先执行。但是我看书上说，这里可能会发生指令重排序，也就是说语句1不一定比语句2先执行。怎么感觉和happens-before规则有点矛盾啊？我知道我可能吗哪儿理解有误区，希望老师给我答疑下。</div>
                            <span class="time">2019-03-03</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">可以重排，但是重排的结果要保证Happens-Before规则<br>int i=0;<br>int j=1;<br>int k = i+j;<br>如果你的代码是上面这样，那么编译器重排成：<br>int j=1;<br>int i=0;<br>int k = i+j;<br>也是可以的。</p>
                                <p class="reply-time">2019-03-03</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/12/bc/eb/c22ef3a5.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">Nevermore</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">这条规则是指对一个锁的解锁 Happens-Before 于后续对这个锁的加锁。<br><br><br>请教老师，如果这个描述反过来，加锁happens-before解锁，这么描述会有什么问题？</div>
                            <span class="time">2019-03-02</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">这个数学题就交给你自己验算吧，要结合其他规则验证两个命题是否等价<br></p>
                                <p class="reply-time">2019-03-03</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">小</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">早点看到这样的文章就不用那么痛苦了</div>
                            <span class="time">2019-03-02</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">我也那么痛苦过</p>
                                <p class="reply-time">2019-03-03</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/11/a9/36/972f7abf.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">木刻</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">@ Nevermore 理解了下这里就是结合了前三条规则，每一个前面的操作的结果对后续是可见的，因此B线程只要读到了v=true，那么必然已经看到了x=42</div>
                            <span class="time">2019-03-02</span>
                            
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/10/87/66/31629628.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">MaO</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">感觉最关键得一点没有解释啊<br><br>violatile 变量写happen before 读，在什么情况下发生?应该是某种并发场景但是有确实有顺序的时候吧，补充下吧？<br>否则会感觉是人为对线程的操控导致的。<br>可能涉及到vm线程调度，希望能讲下不加violatile会出问题的场景</div>
                            <span class="time">2019-03-02</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">双重检查创建单例，不加volatile会出问题。<br>happen before 不是发生在之前的意思。 这个和线程调度没关系。操作系统乐意调度谁就调度谁，JVM算老几？</p>
                                <p class="reply-time">2019-03-02</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/16/01/e7/091804b7.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">长眉_张永</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">volatile关键字，每次都读写入内存。<br>另一种就是happens -before原则，让=3的操作先执行</div>
                            <span class="time">2019-03-02</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">话说，第二种，我是没看明白，你自己明白就好</p>
                                <p class="reply-time">2019-03-02</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/11/1a/56/2f1a8301.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">Four</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">1、共享变量abc使用volatile关键字修饰，volatile关键字可以保证可见性。(但是不能保证原子性)<br><br>2、使用锁，synchronize、ReentrantLock...反正有"互斥"语意就行，锁能够保证操作的原子性<br><br>3、使用CAS无锁算法<br><br>4、Thread#join()</div>
                            <span class="time">2019-03-02</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">单独靠CAS无锁算法，应该搞不定可见性。加上volatile关键字就可以了。</p>
                                <p class="reply-time">2019-03-02</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/10/11/ad/a1c55d98.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">飞落冰雪</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">@senekis 还有一个start规则你没说到</div>
                            <span class="time">2019-03-02</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">没写的那俩规则，就参考《Java并发编程实战》的第16章吧</p>
                                <p class="reply-time">2019-03-02</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/16/0e/e8/5d2c3e08.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">何方妖孽</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">thread的构造函数里是一个箭头函数，这是什么语法？</div>
                            <span class="time">2019-03-02</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">Java8里的Lambda表达式</p>
                                <p class="reply-time">2019-03-02</p></div>
                        </div>
                    </li></ul>
            </div>
        </div> <!----> <!----></div>
</div>
<link rel="dns-prefetch" href="//cdn.mathjax.org">
<script type="text/x-mathjax-config">MathJax.Hub.Config({
        showProcessingMessages: false,
        messageStyle: "none",
        tex2jax: {
          inlineMath: [['$','$'], ['\\(','\\)']],
          displayMath: [ ["$$","$$"] ],
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code', 'a']
        }
      });
      MathJax.Hub.Register.MessageHook("End Process", function (message) {
        var eve = new Event('mathjaxfini')
        window.dispatchEvent(eve)
      })




</script>

</body>