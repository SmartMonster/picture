<head>
    <meta charset="utf-8">
    <meta name="Keywords" content="极客时间,极客邦,极客邦科技,极客邦控股,极客时间App,专栏订阅,极客新闻,二叉树,极客Live,QCon,左耳听风,AI技术内参,大航海时代,陈皓,徐飞,洪亮劼,霍泰稳,池建强,Selina,Gary,InfoQ,极客搜索">
    <meta name="description" content="极客时间是极客邦科技出品的一款 IT 内容知识服务 App，内容包含专栏订阅、极客新闻、热点专题、直播、视频和音频等多形式的知识内容，并设有陈皓专栏、徐飞专栏、洪亮劼专栏等专栏供订阅。">
    <link rel="apple-touch-icon" sizes="180x180" href="//static001.geekbang.org/static/icon/time/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="//static001.geekbang.org/static/icon/time/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="//static001.geekbang.org/static/icon/time/favicon-16x16.png">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no,viewport-fit=cover">
    <meta name="format-detection" content="telephone=no">
    <title>03 | 互斥锁（上）：解决原子性问题</title>

    <link href="https://static001.geekbang.org/static/time/css/app.3e04e644962ca8c2f97ec7731bb7710c.css" rel="stylesheet">
    <style type="text/css">.hljs-ln {
        border-collapse: collapse
    }

    .hljs-ln td {
        padding: 0
    }

    .hljs-ln-n:before {
        content: attr(data-line-number)
    }</style>
    <style type="text/css">#iv-container {
        position: fixed;
        background: #0d0d0d;
        width: 100%;
        height: 100%;
        top: 0;
        left: 0;
        display: none;
        z-index: 1000
    }

    .iv-container {
        overflow: hidden
    }

    .iv-close {
        width: 26px;
        height: 26px;
        position: absolute;
        right: 20px;
        top: 20px;
        cursor: pointer;
        text-align: center;
        overflow: hidden;
        text-shadow: 0 0 3px #6d6d6d;
        -webkit-transition: all .2s ease;
        -moz-transition: all ease .2s;
        -o-transition: all ease .2s;
        transition: all .2s ease
    }

    .iv-close:after, .iv-close:before {
        content: "";
        height: 2px;
        width: 26px;
        background: #fff;
        position: absolute;
        left: 0;
        top: 50%;
        margin-top: -2px;
        border-radius: 2px
    }

    .iv-close:before {
        -webkit-transform: rotate(45deg);
        -moz-transform: rotate(45deg);
        -ms-transform: rotate(45deg);
        -o-transform: rotate(45deg);
        transform: rotate(45deg)
    }

    .iv-close:after {
        -webkit-transform: rotate(-45deg);
        -moz-transform: rotate(-45deg);
        -ms-transform: rotate(-45deg);
        -o-transform: rotate(-45deg);
        transform: rotate(-45deg)
    }

    .iv-close:hover {
        -webkit-transform: rotate(90deg);
        -moz-transform: rotate(90deg);
        -ms-transform: rotate(90deg);
        -o-transform: rotate(90deg);
        transform: rotate(90deg)
    }

    .iv-image-view {
        position: absolute;
        height: 100%;
        width: 100%
    }

    .iv-image-wrap {
        display: inline-block
    }

    .iv-image-wrap:active {
        cursor: move
    }

    .iv-large-image {
        cursor: move;
        max-width: 100%;
        max-height: 100%;
        background-color: #ececec;
        -moz-transform: translateZ(0);
        -o-transform: translateZ(0)
    }

    .iv-large-image, .iv-loader {
        position: absolute;
        -webkit-transform: translateZ(0);
        -ms-transform: translateZ(0);
        transform: translateZ(0)
    }

    .iv-loader {
        top: 50%;
        left: 50%;
        border-radius: 50%;
        width: 32px;
        height: 32px;
        z-index: 100;
        margin-top: -16px;
        margin-left: -16px;
        font-size: 5px;
        text-indent: -9999em;
        border-top: 1em solid hsla(0, 0%, 100%, .2);
        border-right: 1em solid hsla(0, 0%, 100%, .2);
        border-bottom: 1em solid hsla(0, 0%, 100%, .2);
        border-left: 1em solid #fff;
        -webkit-animation: load8 1.1s infinite linear;
        animation: load8 1.1s infinite linear
    }

    .iv-loader:after {
        width: 10em;
        height: 10em;
        border-radius: 50%
    }

    @-webkit-keyframes load8 {
        0% {
            -webkit-transform: rotate(0deg);
            transform: rotate(0deg)
        }
        to {
            -webkit-transform: rotate(1turn);
            transform: rotate(1turn)
        }
    }

    @keyframes load8 {
        0% {
            -webkit-transform: rotate(0deg);
            transform: rotate(0deg)
        }
        to {
            -webkit-transform: rotate(1turn);
            transform: rotate(1turn)
        }
    }</style>
    <style type="text/css">.vue-pull-to-wrapper[data-v-12abd9fb] {
        display: -webkit-box;
        display: -webkit-flex;
        display: flex;
        -webkit-box-orient: vertical;
        -webkit-box-direction: normal;
        -webkit-flex-direction: column;
        flex-direction: column;
        height: 100%
    }

    .scroll-container[data-v-12abd9fb] {
        -webkit-box-flex: 1;
        -webkit-flex: 1;
        flex: 1;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch
    }

    .vue-pull-to-wrapper .action-block[data-v-12abd9fb] {
        position: relative;
        width: 100%
    }

    .default-text[data-v-12abd9fb] {
        height: 100%;
        line-height: 50px;
        text-align: center
    }</style>
    <style type="text/css">.button-cancel[data-v-87ffcada] {
        color: #888;
        border: 1px solid #888;
        border-radius: 3px;
        margin-right: 12px
    }

    .button-cancel[data-v-87ffcada], .button-primary[data-v-87ffcada] {
        -webkit-box-flex: 1;
        -ms-flex-positive: 1;
        flex-grow: 1;
        height: 35px;
        display: inline-block;
        font-size: 15px;
        text-align: center;
        line-height: 36px
    }

    .button-primary[data-v-87ffcada] {
        color: #fff;
        background-color: #ff5a05;
        border-radius: 3px
    }

    .pd[data-v-87ffcada] {
        padding-left: 1.375rem;
        padding-right: 1.375rem
    }

    .article[data-v-87ffcada] {
        max-width: 46.25rem;
        margin: 0 auto
    }

    .article .article-unavailable[data-v-87ffcada] {
        color: #fa8919;
        font-size: 15px;
        font-weight: 600;
        line-height: 24px;
        border-radius: 5px;
        padding: 12px;
        background-color: #f6f7fb;
        margin-top: 20px
    }

    .article .article-unavailable .iconfont[data-v-87ffcada] {
        font-size: 12px
    }

    .article .main[data-v-87ffcada] {
        padding: 1.25rem 0;
        margin-bottom: 52px
    }

    .article-title[data-v-87ffcada] {
        color: #353535;
        font-weight: 400;
        line-height: 1.65rem;
        font-size: 1.34375rem
    }

    .article-info[data-v-87ffcada] {
        color: #888;
        font-size: .9375rem;
        margin-top: 1.0625rem
    }

    .article-content[data-v-87ffcada] {
        margin-top: 1.0625rem
    }

    .article-content.android video[data-v-87ffcada]::-webkit-media-controls-fullscreen-button {
        display: none
    }

    .copyright[data-v-87ffcada] {
        color: #b2b2b2;
        padding-bottom: 20px;
        margin-top: 20px;
        font-size: 13px
    }

    .audio-player[data-v-87ffcada] {
        width: 100%;
        margin: 20px 0
    }

    .to-comment[data-v-87ffcada] {
        overflow: hidden;
        padding-top: 10px;
        margin-bottom: -30px
    }

    .to-comment a.button-primary[data-v-87ffcada] {
        float: right;
        height: 20px;
        font-size: 12px;
        line-height: 20px;
        padding: 4px 8px;
        cursor: pointer
    }

    .article-comments[data-v-87ffcada] {
        margin-top: 2rem
    }

    .article-comments h2[data-v-87ffcada] {
        text-align: center;
        color: #888;
        position: relative;
        z-index: 1;
        margin-bottom: 1rem
    }

    .article-comments h2[data-v-87ffcada]:before {
        border-top: 1px dotted #888;
        content: "";
        position: absolute;
        top: 56%;
        left: 0;
        width: 100%;
        z-index: -1
    }

    .article-comments h2 span[data-v-87ffcada] {
        font-size: 15.25px;
        font-weight: 400;
        padding: 0 1rem;
        background: #fff;
        display: inline-block
    }

    .article-sub-bottom[data-v-87ffcada] {
        z-index: 10;
        cursor: pointer
    }

    .switch-btns[data-v-87ffcada] {
        height: 76px;
        cursor: pointer;
        padding-top: 24px;
        padding-bottom: 24px;
        border-bottom: 10px solid #f6f7fb;
        position: relative
    }

    .switch-btns[data-v-87ffcada]:before {
        content: " ";
        height: 1px;
        background: #e8e8e8;
        position: absolute;
        top: 0;
        left: 0;
        -webkit-box-sizing: border-box;
        box-sizing: border-box;
        left: 1.375rem;
        right: 1.375rem
    }

    .switch-btns .btn[data-v-87ffcada] {
        height: 38px;
        display: -webkit-box;
        display: -ms-flexbox;
        display: flex;
        -webkit-box-align: center;
        -ms-flex-align: center;
        align-items: center
    }

    .switch-btns .btn .tag[data-v-87ffcada] {
        -webkit-box-flex: 0;
        -ms-flex: 0 0 62px;
        flex: 0 0 62px;
        text-align: center;
        color: #888;
        font-size: 14px;
        border-radius: 10px;
        height: 22px;
        line-height: 22px;
        background: #f6f7fb;
        font-weight: 400
    }

    .switch-btns .btn .txt[data-v-87ffcada] {
        margin-left: 10px;
        -webkit-box-flex: 1;
        -ms-flex: 1 1 auto;
        flex: 1 1 auto;
        color: #888;
        font-size: 15px;
        height: 22px;
        line-height: 22px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        font-weight: 400
    }

    @media (max-width: 769px) {
        .article .breadcrumb[data-v-87ffcada] {
            padding-top: 10px;
            padding-bottom: 10px
        }
    }</style>
    <style type="text/css">.empty {
        height: 51px
    }

    .mobile-tips {
        width: 100%;
        height: 51px;
        background: rgba(0, 0, 0, .8);
        position: fixed;
        top: 0;
        left: 0;
        z-index: 20;
        display: -webkit-box;
        display: -ms-flexbox;
        display: flex;
        -webkit-box-orient: horizontal;
        -webkit-box-direction: normal;
        -ms-flex-direction: row;
        flex-direction: row;
        -webkit-box-align: center;
        -ms-flex-align: center;
        align-items: center;
        -webkit-box-pack: justify;
        -ms-flex-pack: justify;
        justify-content: space-between;
        -webkit-box-sizing: border-box;
        box-sizing: border-box;
        padding: 0 12px;
        -webkit-transition: opacity .35s;
        transition: opacity .35s;
        opacity: 0;
        pointer-events: none
    }

    .mobile-tips.istop {
        opacity: 1;
        pointer-events: auto
    }

    .mobile-tips .mobile-tips-info {
        display: -webkit-box;
        display: -ms-flexbox;
        display: flex;
        -webkit-box-orient: horizontal;
        -webkit-box-direction: normal;
        -ms-flex-direction: row;
        flex-direction: row;
        -webkit-box-align: center;
        -ms-flex-align: center;
        align-items: center;
        -webkit-box-pack: start;
        -ms-flex-pack: start;
        justify-content: flex-start
    }

    .mobile-tips .mobile-tips-info i {
        width: 36px;
        height: 36px;
        background-image: url(data:image/png;base64,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);
        background-position: 0 0;
        background-repeat: no-repeat;
        background-size: contain;
        border-radius: 7px
    }

    .mobile-tips .mobile-tips-info h2 {
        font-size: 15px;
        color: #fff;
        font-weight: 400;
        margin-left: 6px
    }

    .mobile-tips .mobile-tips-info h2 span {
        font-size: 11px
    }

    .mobile-tips a {
        width: 72px;
        height: 31px;
        text-align: center;
        border: 1px solid #fa8919;
        border-radius: 3px;
        font-size: 13px;
        color: #fa8919;
        line-height: 31px
    }</style>
    <style type="text/css">.share-poster-wrapper {
        position: fixed;
        background-color: #fff;
        left: 0;
        bottom: 0;
        z-index: 100;
        display: -webkit-box;
        display: -ms-flexbox;
        display: flex;
        overflow: hidden;
        width: 100%;
        -webkit-box-orient: vertical;
        -webkit-box-direction: normal;
        -ms-flex-direction: column;
        flex-direction: column;
        -moz-user-select: -moz-none;
        -webkit-user-select: none;
        -ms-user-select: none;
        user-select: none
    }

    .share-poster-wrapper .poster-bottom, .share-poster-wrapper .poster-middle, .share-poster-wrapper .poster-top {
        -ms-flex-negative: 0;
        flex-shrink: 0
    }

    .share-poster-wrapper .poster-middle {
        padding: 16px 32px;
        -webkit-box-sizing: border-box;
        box-sizing: border-box
    }

    .share-poster-wrapper .poster-middle .poster-userinfo {
        display: -webkit-box;
        display: -ms-flexbox;
        display: flex;
        -webkit-box-align: center;
        -ms-flex-align: center;
        align-items: center;
        padding-bottom: 18px
    }

    .share-poster-wrapper .poster-middle .poster-userinfo .poster-avatar {
        min-width: 45px;
        min-height: 45px;
        width: 7vw;
        height: 7vw;
        border-radius: 50%;
        -ms-flex-negative: 0;
        flex-shrink: 0
    }

    .share-poster-wrapper .poster-middle .nickname {
        font-size: 5vw;
        font-weight: 400;
        margin-left: 18px
    }

    .share-poster-wrapper .poster-middle .time {
        font-size: 3.2vw
    }

    .share-poster-wrapper .poster-middle .poster-middle-content {
        font-size: 4vw;
        font-weight: 400;
        white-space: normal;
        word-wrap: break-word;
        word-break: break-word;
        letter-spacing: 1px
    }

    .share-poster-wrapper .poster-middle .poster-middle-content p {
        margin-bottom: 22px
    }

    .share-poster-wrapper .poster-middle .quote-content {
        font-size: 3.7vw;
        padding: 32px 0
    }

    .share-poster-wrapper .poster-middle .quote-content p {
        margin-bottom: 22px
    }

    .share-poster-wrapper .poster-middle .quote-info {
        border-left: 1px solid #000;
        padding-left: 10px;
        margin-top: 38px
    }

    .share-poster-wrapper .poster-middle .quote-info p {
        font-size: 3.2vw;
        line-height: 1.5
    }

    .share-poster-wrapper.theme0 .poster-top {
        width: 100%;
        height: 25px;
        margin-top: 27px;
        background: url("https://static001.geekbang.org/static/time/page/img/sharePoster/theme1/top.png") no-repeat 15px 1px
    }

    .share-poster-wrapper.theme0 .poster-middle {
        width: 100%;
        padding-left: 56px;
        padding-right: 56px;
        background-image: url("https://static001.geekbang.org/static/time/page/img/sharePoster/theme1/middle.png");
        background-repeat: repeat-y;
        background-position: 15px 0
    }

    .share-poster-wrapper.theme0 .poster-middle .time {
        margin-bottom: 45px
    }

    .share-poster-wrapper.theme0 .poster-middle .quote-content {
        border-top: 1px solid #e3e1dc;
        margin-top: 30px
    }

    .share-poster-wrapper.theme0 .poster-bottom {
        width: 100%;
        height: 25px;
        margin-bottom: 27px;
        background: url("https://static001.geekbang.org/static/time/page/img/sharePoster/theme1/bottom.png") no-repeat 15px -10px
    }

    .share-poster-wrapper.theme1 .poster-top {
        width: 100%;
        height: 25px;
        margin-top: 27px;
        background: url("https://static001.geekbang.org/static/time/page/img/sharePoster/theme0/top.png") no-repeat 38px 1px
    }

    .share-poster-wrapper.theme1 .poster-middle {
        width: 100%;
        padding: 0 42px 10px;
        background: url("https://static001.geekbang.org/static/time/page/img/sharePoster/theme0/middle.png") repeat-y 38px 0
    }

    .share-poster-wrapper.theme1 .poster-middle .poster-userinfo {
        border-bottom: 1px solid #b5a899
    }

    .share-poster-wrapper.theme1 .poster-middle .poster-userinfo .poster-avatar {
        margin-left: 38px
    }

    .share-poster-wrapper.theme1 .poster-middle .poster-middle-wrapper {
        display: -webkit-box;
        display: -ms-flexbox;
        display: flex;
        -webkit-box-orient: horizontal;
        -webkit-box-direction: normal;
        -ms-flex-direction: row;
        flex-direction: row;
        min-height: 260px;
        border-bottom: 1px solid #b5a899
    }

    .share-poster-wrapper.theme1 .poster-middle .time {
        max-width: 65px;
        display: -webkit-box;
        display: -ms-flexbox;
        display: flex;
        -webkit-box-orient: vertical;
        -webkit-box-direction: normal;
        -ms-flex-direction: column;
        flex-direction: column;
        -webkit-box-pack: center;
        -ms-flex-pack: center;
        justify-content: center;
        -webkit-box-align: center;
        -ms-flex-align: center;
        align-items: center;
        text-align: center;
        vertical-align: middle;
        border-right: 1px solid #b5a899
    }

    .share-poster-wrapper.theme1 .poster-middle .time span {
        white-space: nowrap;
        -webkit-transform: rotate(90deg);
        transform: rotate(90deg)
    }

    .share-poster-wrapper.theme1 .poster-middle .poster-middle-content {
        padding: 30px
    }

    .share-poster-wrapper.theme1 .poster-middle .quote-content {
        font-size: 3.7vw;
        margin-left: 36px;
        margin-right: 36px
    }

    .share-poster-wrapper.theme1 .poster-middle .quote-info {
        margin-left: 36px;
        margin-right: 36px
    }

    .share-poster-wrapper.theme1 .poster-middle .footer {
        display: -webkit-box;
        display: -ms-flexbox;
        display: flex;
        -webkit-box-orient: horizontal;
        -webkit-box-direction: normal;
        -ms-flex-direction: row;
        flex-direction: row;
        margin-right: 30px
    }

    .share-poster-wrapper.theme1 .poster-bottom {
        width: 100%;
        height: 25px;
        margin-bottom: 27px;
        background: url("https://static001.geekbang.org/static/time/page/img/sharePoster/theme0/bottom.png") no-repeat 38px -10px
    }

    .share-poster-wrapper .share-poster {
        background: #fefdf8;
        -webkit-box-sizing: border-box;
        box-sizing: border-box;
        color: #9b8d73;
        -webkit-box-flex: 1;
        -ms-flex-positive: 1;
        flex-grow: 1;
        overflow: auto;
        display: -webkit-box;
        display: -ms-flexbox;
        display: flex;
        -webkit-box-orient: vertical;
        -webkit-box-direction: normal;
        -ms-flex-direction: column;
        flex-direction: column;
        -webkit-overflow-scrolling: touch;
        -webkit-box-align: center;
        -ms-flex-align: center;
        align-items: center
    }

    .share-poster-wrapper .share-poster.color0 {
        background-color: #fefdf8
    }

    .share-poster-wrapper .share-poster.color1 {
        background-color: #4d4d4d
    }

    .share-poster-wrapper .share-poster .footer {
        margin-top: 2rem;
        position: relative;
        display: -webkit-box;
        display: -ms-flexbox;
        display: flex;
        -webkit-box-orient: horizontal;
        -webkit-box-direction: normal;
        -ms-flex-direction: row;
        flex-direction: row;
        -webkit-box-pack: end;
        -ms-flex-pack: end;
        justify-content: flex-end;
        -webkit-box-align: end;
        -ms-flex-align: end;
        align-items: flex-end
    }

    .share-poster-wrapper .share-poster .footer p {
        margin: 0;
        line-height: 1.4;
        margin-left: 20px;
        text-align: right;
        padding-right: 20px
    }

    .share-poster-wrapper .controls {
        background: #fff;
        border-top: 1px solid #f5f5f5;
        width: 100%;
        padding-top: 5px;
        -webkit-box-shadow: 0 -4px 10px 0 rgba(0, 0, 0, .1);
        box-shadow: 0 -4px 10px 0 rgba(0, 0, 0, .1);
        z-index: 1;
        -ms-flex-negative: 0;
        flex-shrink: 0
    }

    .share-poster-wrapper .controls > div {
        display: -webkit-box;
        display: -ms-flexbox;
        display: flex;
        -webkit-box-orient: horizontal;
        -webkit-box-direction: normal;
        -ms-flex-direction: row;
        flex-direction: row;
        -webkit-box-pack: center;
        -ms-flex-pack: center;
        justify-content: center;
        -webkit-box-align: center;
        -ms-flex-align: center;
        align-items: center;
        padding: 10px 0
    }

    .share-poster-wrapper .controls > div span {
        font-size: .85rem
    }

    .share-poster-wrapper .controls > div button {
        width: 100px;
        height: 24px;
        background: #eee;
        margin: 0 10px;
        border-radius: 5px;
        border: 2px solid #b2b2b2;
        outline: none
    }

    .share-poster-wrapper .controls > div button.on {
        border: 2px solid #ff5a05
    }

    .share-poster-wrapper .controls .controls-themes button {
        color: #b2b2b2;
        font-size: 12px;
        background: #fff;
        text-align: center
    }

    .share-poster-wrapper .controls .controls-themes button.on {
        color: #ff5a05
    }

    .share-poster-wrapper .buttons {
        background: #fff;
        border-top: 1px solid #f5f5f5;
        display: -webkit-box;
        display: -ms-flexbox;
        display: flex;
        -webkit-box-orient: horizontal;
        -webkit-box-direction: normal;
        -ms-flex-direction: row;
        flex-direction: row;
        -ms-flex-negative: 0;
        flex-shrink: 0
    }

    .share-poster-wrapper .buttons a {
        -webkit-box-flex: 1;
        -ms-flex-positive: 1;
        flex-grow: 1;
        text-align: center;
        color: #000;
        font-weight: 400;
        height: 3rem;
        line-height: 3rem
    }

    .share-poster-wrapper .buttons a .icon-share-money {
        width: 1rem;
        height: 1rem;
        margin: 3px 0 0 5px
    }

    .share-poster-wrapper .buttons a:last-child {
        border-left: 1px solid #f5f5f5
    }

    .share-poster-wrapper img {
        max-width: 100%
    }

    .share-poster-wrapper.android .poster-middle .nickname {
        font-size: 10vw
    }

    .share-poster-wrapper.android .poster-middle .time {
        font-size: 6.4vw
    }

    .share-poster-wrapper.android .poster-middle .poster-middle-content {
        font-size: 8vw
    }

    .share-poster-wrapper.android .poster-middle .quote-content {
        font-size: 7.4vw
    }

    .share-poster-wrapper.android .poster-middle .quote-info p {
        font-size: 6.4vw
    }</style>
    <style type="text/css">.mini-audio-player {
        width: 100%;
        height: 5.25rem;
        border: 1px solid #d9d9d9;
        background: #fafafa;
        -webkit-box-sizing: border-box;
        box-sizing: border-box;
        padding: 1rem;
        display: -webkit-box;
        display: -ms-flexbox;
        display: flex;
        -webkit-box-orient: horizontal;
        -webkit-box-direction: normal;
        -ms-flex-direction: row;
        flex-direction: row;
        -webkit-box-align: center;
        -ms-flex-align: center;
        align-items: center;
        -webkit-box-pack: justify;
        -ms-flex-pack: justify;
        justify-content: space-between;
        margin: 1rem 0
    }

    .mini-audio-player > a {
        border: none;
        -ms-flex-negative: 0;
        flex-shrink: 0
    }

    .mini-audio-player .btn-play {
        background-image: url(data:image/png;base64,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)
    }

    .mini-audio-player .btn-pause, .mini-audio-player .btn-play {
        width: 2.6875rem;
        height: 2.6875rem;
        background-repeat: no-repeat;
        background-position: 0 0;
        background-size: contain;
        text-decoration: none
    }

    .mini-audio-player .btn-pause {
        background-image: url(data:image/png;base64,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)
    }

    .mini-audio-player .audio-info {
        display: -webkit-box;
        display: -ms-flexbox;
        display: flex;
        -webkit-box-flex: 1;
        -ms-flex-positive: 1;
        flex-grow: 1;
        -webkit-box-orient: vertical;
        -webkit-box-direction: normal;
        -ms-flex-direction: column;
        flex-direction: column;
        margin-left: .6875rem;
        min-width: 0
    }

    .mini-audio-player .audio-info h3 {
        color: #353535;
        font-size: 15.25px;
        margin: 0;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis
    }

    .mini-audio-player .audio-info p {
        margin: 0;
        margin-top: .125rem;
        font-size: 11px;
        line-height: 1rem
    }

    .mini-audio-player .audio-info p span {
        color: #888
    }

    .mini-audio-player .btn-download {
        width: 1.25rem;
        height: 1.25rem;
        position: relative;
        background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAA+CAYAAACbQR1vAAABS2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxMzggNzkuMTU5ODI0LCAyMDE2LzA5LzE0LTAxOjA5OjAxICAgICAgICAiPgogPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIi8+CiA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgo8P3hwYWNrZXQgZW5kPSJyIj8+IEmuOgAAA4hJREFUaIHtm8lOFFEUhr9qCWGHGxcaY1joK2h0YRzAtYmsWbAGGidEXOACbAYRxfgAPoEPoInGxJgg86gsJTHMw86EhS7O7TDk3uqq6qo6HahvQ7pOce7//1U0feve9vr6+lAiD3QC/4AC8FZDRJXGoMB14PWB1yPANPA1bSG5tAc0XLEcu5y6CvQCOGU5pnI3agVQMWQBaAvQJgtAW4A2WQDaArTJAtAWoE0WgLYAbbIAtAVokwWgLUCbLABtAdpkAfjU6oC7wKV0pCTCRcRDnesEVwDNwC/gg/nZHbeyFOgGltj30Gw7yRZALfAOqDavPeA50BO7xOToQTR75nU14qn26Im2AM4DNZbjz4DeePQlSi+i9Sg1iLdD2AJYApYdzbuo7BBeIBptLCPeDmELYA9oBHYdjbqQpaxKowA8ddR2gXuIt0O43gRHgTu4Q+ikskIoIJps7AINwA9b0e/fYJAQ1FZWD9CP2/wOUI/DPJT+IDRqGrhCeGIEaNEPdDhqO8iVH/NrEOST4BgSwo6j3gEMBOgTNwP4m6+nhHkI/lG4VAiPgcGAveJg0IxpYxvROh6kUZi5wLhpvO2oPyKdEF6asWyEMg/hJ0PjyN+VXwhDIXuGYQh46KhtIeYnwjSMMhss3glbjvoDkglhyPS2Eck8RJ8OTyB3gl8IryL2tjGM2/wmYn4ySuNyngdMmIE3HfX7iHDPUQ+CZ3q0O+qbyIWIZB7KfyAyaQS4QmhH7oQoIZQyv0EZV75IHE+EJvG/E9oJfyd4yC6yvKO+gQQ/FaKnlbgeiU0hIWw46nnEUJAQiubbHPV1M1bZ5iHeZ4KlQmgD3uAfgofsGfQz34DsKYyFuLemTSMhfATOWOqtiMk/llrRfIuj9zpwG5gtX+Y+SezNK4bwCXsILdgDaAXOOnomYh6Seyw+gwhed9TPWY75mb9FAuYh2XWBWUS4K4QgrAE3gblYFFlIemFkDjEQJYQ1JMD5WBUdIY2VoXkkhLUQv7NqfidR85De0liYEFaRK7+QqCJDmmuDC0gIqz7nrJhzUjEP6S+O+oWwglz5xTQFaawOLwI3gO8Hjo2ZY6maB72vzPwErgEXkO8MuVaiEkcrgCK/lcfPNkhkAWgL0KYKmZiMIG9Ktn0Bx5G/wDcgXwW8R6avJ41G4HQOufInlas5ZO5+UpnJAU3AFyy7J44xe8BnoOk/JruwYo92bigAAAAASUVORK5CYII=);
        background-repeat: no-repeat;
        background-position: 0 0;
        background-size: contain;
        text-decoration: none;
        padding-right: .25rem
    }

    .mini-audio-player .btn-download .icon-download-done {
        width: .45rem;
        height: .45rem;
        position: absolute;
        bottom: 0;
        right: 0;
        display: inline-block;
        background-image: url(data:image/png;base64,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);
        background-repeat: no-repeat;
        background-position: 0 0;
        background-size: contain
    }</style>
    <style type="text/css">.MathJax_Display {
        overflow: auto
    }

    .poster {
        position: fixed;
        left: -10000px;
        top: -10000px;
        overflow: hidden;
        padding: 1rem;
        background: #ececec
    }

    .richcontent-pre-copy {
        font-size: 13px;
        color: #888;
        position: absolute;
        right: 1em;
        top: .2em;
        cursor: pointer;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none
    }

    .richcontent-pre-copy .iconfont {
        font-size: 12px;
        margin-right: .2em
    }</style>
    <style type="text/css">.breadcrumb {
        padding: 30px 0;
        display: -webkit-box;
        display: -ms-flexbox;
        display: flex;
        -webkit-box-orient: horizontal;
        -webkit-box-direction: normal;
        -ms-flex-direction: row;
        flex-direction: row;
        -webkit-box-align: center;
        -ms-flex-align: center;
        align-items: center;
        -ms-flex-wrap: wrap;
        flex-wrap: wrap;
        background: #fff
    }

    .breadcrumb a.title {
        color: #e57c39;
        font-size: 15px;
        font-weight: 400
    }

    .breadcrumb span.title {
        color: #888;
        font-size: 15px;
        font-weight: 400
    }

    .breadcrumb .split {
        color: #ccc;
        font-size: 10px;
        margin-right: 5px
    }</style>
    <style type="text/css">.comment-item {
        list-style-position: inside;
        width: 100%;
        display: -webkit-box;
        display: -ms-flexbox;
        display: flex;
        -webkit-box-orient: horizontal;
        -webkit-box-direction: normal;
        -ms-flex-direction: row;
        flex-direction: row;
        margin-bottom: 1rem
    }

    .comment-item a {
        border-bottom: none
    }

    .comment-item .avatar {
        width: 2.625rem;
        height: 2.625rem;
        -ms-flex-negative: 0;
        flex-shrink: 0;
        border-radius: 50%
    }

    .comment-item .info {
        margin-left: .5rem;
        -webkit-box-flex: 1;
        -ms-flex-positive: 1;
        flex-grow: 1
    }

    .comment-item .info .hd {
        width: 100%;
        display: -webkit-box;
        display: -ms-flexbox;
        display: flex;
        -webkit-box-orient: horizontal;
        -webkit-box-direction: normal;
        -ms-flex-direction: row;
        flex-direction: row;
        -webkit-box-pack: justify;
        -ms-flex-pack: justify;
        justify-content: space-between;
        -webkit-box-align: center;
        -ms-flex-align: center;
        align-items: center
    }

    .comment-item .info .hd .username {
        color: #888;
        font-size: 15.25px;
        font-weight: 400;
        line-height: 1.2
    }

    .comment-item .info .hd .control {
        display: -webkit-box;
        display: -ms-flexbox;
        display: flex;
        -webkit-box-orient: horizontal;
        -webkit-box-direction: normal;
        -ms-flex-direction: row;
        flex-direction: row;
        -webkit-box-align: center;
        -ms-flex-align: center;
        align-items: center
    }

    .comment-item .info .hd .control .btn-share {
        color: #888;
        font-size: .75rem;
        margin-right: 1rem
    }

    .comment-item .info .hd .control .btn-praise {
        display: -webkit-box;
        display: -ms-flexbox;
        display: flex;
        -webkit-box-orient: horizontal;
        -webkit-box-direction: normal;
        -ms-flex-direction: row;
        flex-direction: row;
        -webkit-box-align: center;
        -ms-flex-align: center;
        align-items: center;
        font-size: 15.25px;
        text-decoration: none
    }

    .comment-item .info .hd .control .btn-praise i {
        color: #888;
        display: inline-block;
        font-size: .75rem;
        margin-right: .3rem;
        margin-top: -.01rem
    }

    .comment-item .info .hd .control .btn-praise i.on, .comment-item .info .hd .control .btn-praise span {
        color: #fa8919
    }

    .comment-item .info .bd {
        color: #353535;
        font-size: 15.25px;
        font-weight: 400;
        white-space: normal;
        word-break: break-all;
        line-height: 1.6
    }

    .comment-item .info .time {
        color: #888;
        font-size: 9px;
        line-height: 1
    }

    .comment-item .info .reply .reply-hd {
        font-size: 15.25px
    }

    .comment-item .info .reply .reply-hd span {
        margin-left: -12px;
        color: #888;
        font-weight: 400
    }

    .comment-item .info .reply .reply-hd i {
        color: #fa8919;
        font-size: 15.25px
    }

    .comment-item .info .reply .reply-content {
        color: #353535;
        font-size: 15.25px;
        font-weight: 400;
        white-space: normal;
        word-break: break-all
    }

    .comment-item .info .reply .reply-time {
        color: #888;
        font-size: 9px
    }

    .comment-template {
        display: none;
    }
    </style>
</head>
<body>

<div id="app">
    <div data-v-87ffcada="" class="article"><!---->
        <div data-v-87ffcada="" class="main main-app">
            <h1 data-v-87ffcada="" class="article-title pd">
                03 | 互斥锁（上）：解决原子性问题
            </h1>
            <div data-v-87ffcada="" class="article-info pd"><span data-v-87ffcada="">2019-03-05</span> <span data-v-87ffcada="">王宝令</span></div>
            <div data-v-87ffcada="" class="article-content typo common-content pd">
                <img data-v-87ffcada="" src="https://static001.geekbang.org/resource/image/c1/e5/c19b0148575cbd819f54d4a04dd8dde5.jpg">
                <!---->
                <div data-v-87ffcada="" class="mini-audio-player">
                    <div class="audio-info">
                        <p><span>朗读人：王宝令&nbsp;&nbsp;&nbsp;</span>
                        </p></div> <!---->
                    <audio title="" src="https://static001.geekbang.org/resource/audio/c3/c3/c3944240aa84b97548046226397980c3.mp3" controls="controls"></audio>
                </div>
                <div data-v-87ffcada="" id="article-content" class="">
                    <div class="text"><p>在<a href="https://time.geekbang.org/column/article/83682">第一篇文章</a>中我们提到，一个或者多个操作在CPU执行的过程中不被中断的特性，称为“原子性”。理解这个特性有助于你分析并发编程Bug出现的原因，例如利用它可以分析出long型变量在32位机器上读写可能出现的诡异Bug，明明已经把变量成功写入内存，重新读出来却不是自己写入的。</p><p><strong>那原子性问题到底该如何解决呢？</strong></p><p>你已经知道，原子性问题的源头是<strong>线程切换</strong>，如果能够禁用线程切换那不就能解决这个问题了吗？而操作系统做线程切换是依赖CPU中断的，所以禁止CPU发生中断就能够禁止线程切换。</p><p>在早期单核CPU时代，这个方案的确是可行的，而且也有很多应用案例，但是并不适合多核场景。这里我们以32位CPU上执行long型变量的写操作为例来说明这个问题，long型变量是64位，在32位CPU上执行写操作会被拆分成两次写操作（写高32位和写低32位，如下图所示）。</p><p><img src="https://static001.geekbang.org/resource/image/38/28/381b657801c48b3399f19d946bad9e28.png" alt=""></p><p>在单核CPU场景下，同一时刻只有一个线程执行，禁止CPU中断，意味着操作系统不会重新调度线程，也就是禁止了线程切换，获得CPU使用权的线程就可以不间断地执行，所以两次写操作一定是：要么都被执行，要么都没有被执行，具有原子性。</p><p>但是在多核场景下，同一时刻，有可能有两个线程同时在执行，一个线程执行在CPU-1上，一个线程执行在CPU-2上，此时禁止CPU中断，只能保证CPU上的线程连续执行，并不能保证同一时刻只有一个线程执行，如果这两个线程同时写long型变量高32位的话，那就有可能出现我们开头提及的诡异Bug了。</p><!-- [[[read_end]]] --><p>“<strong>同一时刻只有一个线程执行</strong>”这个条件非常重要，我们称之为<strong>互斥</strong>。如果我们能够保证对共享变量的修改是互斥的，那么，无论是单核CPU还是多核CPU，就都能保证原子性了。</p><h2>简易锁模型</h2><p>当谈到互斥，相信聪明的你一定想到了那个杀手级解决方案：锁。同时大脑中还会出现以下模型：</p><p><img src="https://static001.geekbang.org/resource/image/3d/a2/3df991e7de14a788b220468836cd48a2.png" alt=""></p><center><span class="reference">简易锁模型</span></center><p>我们把一段需要互斥执行的代码称为<strong>临界区</strong>。线程在进入临界区之前，首先尝试加锁lock()，如果成功，则进入临界区，此时我们称这个线程持有锁；否则呢就等待，直到持有锁的线程解锁；持有锁的线程执行完临界区的代码后，执行解锁unlock()。</p><p>这个过程非常像办公室里高峰期抢占坑位，每个人都是进坑锁门（加锁），出坑开门（解锁），如厕这个事就是临界区。很长时间里，我也是这么理解的。这样理解本身没有问题，但却很容易让我们忽视两个非常非常重要的点：我们锁的是什么？我们保护的又是什么？</p><h2>改进后的锁模型</h2><p>我们知道在现实世界里，锁和锁要保护的资源是有对应关系的，比如你用你家的锁保护你家的东西，我用我家的锁保护我家的东西。在并发编程世界里，锁和资源也应该有这个关系，但这个关系在我们上面的模型中是没有体现的，所以我们需要完善一下我们的模型。</p><p><img src="https://static001.geekbang.org/resource/image/28/2f/287008c8137a43fa032e68a0c23c172f.png" alt=""></p><center><span class="reference">改进后的锁模型</span></center><p>首先，我们要把临界区要保护的资源标注出来，如图中临界区里增加了一个元素：受保护的资源R；其次，我们要保护资源R就得为它创建一把锁LR；最后，针对这把锁LR，我们还需在进出临界区时添上加锁操作和解锁操作。另外，在锁LR和受保护资源之间，我特地用一条线做了关联，这个关联关系非常重要。很多并发Bug的出现都是因为把它忽略了，然后就出现了类似锁自家门来保护他家资产的事情，这样的Bug非常不好诊断，因为潜意识里我们认为已经正确加锁了。</p><h2>Java语言提供的锁技术：synchronized</h2><p>锁是一种通用的技术方案，Java语言提供的synchronized关键字，就是锁的一种实现。synchronized关键字可以用来修饰方法，也可以用来修饰代码块，它的使用示例基本上都是下面这个样子：</p><pre><code>class X {
  // 修饰非静态方法
  synchronized void foo() {
    // 临界区
  }
  // 修饰静态方法
  synchronized static void bar() {
    // 临界区
  }
  // 修饰代码块
  Object obj = new Object()；
  void baz() {
    synchronized(obj) {
      // 临界区
    }
  }
}  
</code></pre><p>看完之后你可能会觉得有点奇怪，这个和我们上面提到的模型有点对不上号啊，加锁lock()和解锁unlock()在哪里呢？其实这两个操作都是有的，只是这两个操作是被Java默默加上的，Java编译器会在synchronized修饰的方法或代码块前后自动加上加锁lock()和解锁unlock()，这样做的好处就是加锁lock()和解锁unlock()一定是成对出现的，毕竟忘记解锁unlock()可是个致命的Bug（意味着其他线程只能死等下去了）。</p><p>那synchronized里的加锁lock()和解锁unlock()锁定的对象在哪里呢？上面的代码我们看到只有修饰代码块的时候，锁定了一个obj对象，那修饰方法的时候锁定的是什么呢？这个也是Java的一条隐式规则：</p><blockquote>
<p>当修饰静态方法的时候，锁定的是当前类的Class对象，在上面的例子中就是Class X；<br>
当修饰非静态方法的时候，锁定的是当前实例对象this。</p>
</blockquote><p>对于上面的例子，synchronized修饰静态方法相当于:</p><pre><code>class X {
  // 修饰静态方法
  synchronized(X.class) static void bar() {
    // 临界区
  }
}
</code></pre><p>修饰非静态方法，相当于：</p><pre><code>class X {
  // 修饰非静态方法
  synchronized(this) void foo() {
    // 临界区
  }
}
</code></pre><h2>用synchronized解决count+=1问题</h2><p>相信你一定记得我们前面文章中提到过的count+=1存在的并发问题，现在我们可以尝试用synchronized来小试牛刀一把，代码如下所示。SafeCalc这个类有两个方法：一个是get()方法，用来获得value的值；另一个是addOne()方法，用来给value加1，并且addOne()方法我们用synchronized修饰。那么我们使用的这两个方法有没有并发问题呢？</p><pre><code>class SafeCalc {
  long value = 0L;
  long get() {
    return value;
  }
  synchronized void addOne() {
    value += 1;
  }
}
</code></pre><p>我们先来看看addOne()方法，首先可以肯定，被synchronized修饰后，无论是单核CPU还是多核CPU，只有一个线程能够执行addOne()方法，所以一定能保证原子操作，那是否有可见性问题呢？要回答这问题，就要重温一下<a href="https://time.geekbang.org/column/article/84017">上一篇文章</a>中提到的<strong>管程中锁的规则</strong>。</p><blockquote>
<p>管程中锁的规则：对一个锁的解锁 Happens-Before 于后续对这个锁的加锁。</p>
</blockquote><p>管程，就是我们这里的synchronized（至于为什么叫管程，我们后面介绍），我们知道synchronized修饰的临界区是互斥的，也就是说同一时刻只有一个线程执行临界区的代码；而所谓“对一个锁解锁  Happens-Before 后续对这个锁的加锁”，指的是前一个线程的解锁操作对后一个线程的加锁操作可见，综合Happens-Before的传递性原则，我们就能得出前一个线程在临界区修改的共享变量（该操作在解锁之前），对后续进入临界区（该操作在加锁之后）的线程是可见的。</p><p>按照这个规则，如果多个线程同时执行addOne()方法，可见性是可以保证的，也就说如果有1000个线程执行addOne()方法，最终结果一定是value的值增加了1000。看到这个结果，我们长出一口气，问题终于解决了。</p><p>但也许，你一不小心就忽视了get()方法。执行addOne()方法后，value的值对get()方法是可见的吗？这个可见性是没法保证的。管程中锁的规则，是只保证后续对这个锁的加锁的可见性，而get()方法并没有加锁操作，所以可见性没法保证。那如何解决呢？很简单，就是get()方法也synchronized一下，完整的代码如下所示。</p><pre><code>class SafeCalc {
  long value = 0L;
  synchronized long get() {
    return value;
  }
  synchronized void addOne() {
    value += 1;
  }
}
</code></pre><p>上面的代码转换为我们提到的锁模型，就是下面图示这个样子。get()方法和addOne()方法都需要访问value这个受保护的资源，这个资源用this这把锁来保护。线程要进入临界区get()和addOne()，必须先获得this这把锁，这样get()和addOne()也是互斥的。</p><p><img src="https://static001.geekbang.org/resource/image/26/f6/26a84ffe2b4a6ae67c8093d29473e1f6.png" alt=""></p><center><span class="reference">保护临界区get()和addOne()的示意图</span></center><p>这个模型更像现实世界里面球赛门票的管理，一个座位只允许一个人使用，这个座位就是“受保护资源”，球场的入口就是Java类里的方法，而门票就是用来保护资源的“锁”，Java里的检票工作是由synchronized解决的。</p><h2>锁和受保护资源的关系</h2><p>我们前面提到，受保护资源和锁之间的关联关系非常重要，他们的关系是怎样的呢？一个合理的关系是：<strong>受保护资源和锁之间的关联关系是N:1的关系</strong>。还拿前面球赛门票的管理来类比，就是一个座位，我们只能用一张票来保护，如果多发了重复的票，那就要打架了。现实世界里，我们可以用多把锁来保护同一个资源，但在并发领域是不行的，并发领域的锁和现实世界的锁不是完全匹配的。不过倒是可以用同一把锁来保护多个资源，这个对应到现实世界就是我们所谓的“包场”了。</p><p>上面那个例子我稍作改动，把value改成静态变量，把addOne()方法改成静态方法，此时get()方法和addOne()方法是否存在并发问题呢？</p><pre><code>class SafeCalc {
  static long value = 0L;
  synchronized long get() {
    return value;
  }
  synchronized static void addOne() {
    value += 1;
  }
}
</code></pre><p>如果你仔细观察，就会发现改动后的代码是用两个锁保护一个资源。这个受保护的资源就是静态变量value，两个锁分别是this和SafeCalc.class。我们可以用下面这幅图来形象描述这个关系。由于临界区get()和addOne()是用两个锁保护的，因此这两个临界区没有互斥关系，临界区addOne()对value的修改对临界区get()也没有可见性保证，这就导致并发问题了。</p><p><img src="https://static001.geekbang.org/resource/image/60/be/60551e006fca96f581f3dc25424226be.png" alt=""></p><center><span class="reference">两把锁保护一个资源的示意图</span></center><h2>总结</h2><p>互斥锁，在并发领域的知名度极高，只要有了并发问题，大家首先容易想到的就是加锁，因为大家都知道，加锁能够保证执行临界区代码的互斥性。这样理解虽然正确，但是却不能够指导你真正用好互斥锁。临界区的代码是操作受保护资源的路径，类似于球场的入口，入口一定要检票，也就是要加锁，但不是随便一把锁都能有效。所以必须深入分析锁定的对象和受保护资源的关系，综合考虑受保护资源的访问路径，多方面考量才能用好互斥锁。</p><p>synchronized是Java在语言层面提供的互斥原语，其实Java里面还有很多其他类型的锁，但作为互斥锁，原理都是相通的：锁，一定有一个要锁定的对象，至于这个锁定的对象要保护的资源以及在哪里加锁/解锁，就属于设计层面的事情了。</p><h2>课后思考</h2><p>下面的代码用synchronized修饰代码块来尝试解决并发问题，你觉得这个使用方式正确吗？有哪些问题呢？能解决可见性和原子性问题吗？</p><pre><code>class SafeCalc {
  long value = 0L;
  long get() {
    synchronized (new Object()) {
      return value;
    }
  }
  void addOne() {
    synchronized (new Object()) {
      value += 1;
    }
  }
}
</code></pre><p>欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。</p><p><img src="https://static001.geekbang.org/resource/image/cf/aa/cf393cd748a4f0e6451807c4b61843aa.jpg" alt=""></p></div>
                </div> <!---->
                <div data-v-87ffcada="" class="copyright">
                    ©版权归极客邦科技所有，未经许可不得转载
                </div>
            </div>
            <div data-v-87ffcada="" class="article-comments pd"><h2 data-v-87ffcada=""><span data-v-87ffcada="">精选留言</span></h2>
                <ul data-v-87ffcada="">

                    <li data-v-87ffcada="" class="comment-item comment-template">
                        <img src="${user_header}" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">${user_name}</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">${like_count}</span></a></div>
                            </div>
                            <div class="bd comment-content">${comment_content}
                            </div>
                            <span class="time">${comment_ctime}</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">${user_name}</span></div>
                                <p class="reply-content">${content}</p>
                                <p class="reply-time">${ctime}</p></div>
                        </div>
                    </li>
                <li data-v-87ffcada="" class="comment-item">
                        <img src="" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">nonohony</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">143</span></a></div>
                            </div>
                            <div class="bd comment-content">加锁本质就是在锁对象的对象头中写入当前线程id，但是new object每次在内存中都是新对象，所以加锁无效。</div>
                            <span class="time">2019-03-05</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">synchronized的实现都知道了，厉害！</p>
                                <p class="reply-time">2019-03-05</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epY7qGk5GXlibDY3f88RsZZUicUaLuiaIXfIGiczS54kD1hNobYWxcCFHCyiaEru9wpcWuI9WcBB7oNRfA/132" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">zyl</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">37</span></a></div>
                            </div>
                            <div class="bd comment-content">sync锁的对象monitor指针指向一个ObjectMonitor对象，所有线程加入他的entrylist里面，去cas抢锁，更改state加1拿锁，执行完代码，释放锁state减1，和aqs机制差不多，只是所有线程不阻塞，cas抢锁，没有队列，属于非公平锁。<br>wait的时候，线程进waitset休眠，等待notify唤醒<br><br></div>
                            <span class="time">2019-03-05</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">sync的优化都知道了，厉害啊</p>
                                <p class="reply-time">2019-03-05</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erBkHFLUBpftqQlK5brd3EDaQFaEfYLfc9iaQrDNJv4eHeSRnSgE5vKnSibJvjUb5hJx5r5nOwa2bRw/132" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">w1sl1y</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">34</span></a></div>
                            </div>
                            <div class="bd comment-content">经过JVM逃逸分析的优化后，这个sync代码直接会被优化掉，所以在运行时该代码块是无锁的</div>
                            <span class="time">2019-03-05</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">👍厉害<br></p>
                                <p class="reply-time">2019-03-06</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/0f/ee/d2/7024431c.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">探索无止境</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">29</span></a></div>
                            </div>
                            <div class="bd comment-content">不能，因为new了，所以不是同一把锁。老师您好，我对那 synchronized的理解是这样，它并不能改变CPU时间片切换的特点，只是当其他线程要访问这个资源时，发现锁还未释放，所以只能在外面等待，不知道理解是否正确</div>
                            <span class="time">2019-03-05</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">理解正确！</p>
                                <p class="reply-time">2019-03-05</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/13/03/f7/3a493bec.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">老杨同志</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">21</span></a></div>
                            </div>
                            <div class="bd comment-content">两把不同的锁，不能保护临界资源。而且这种new出来只在一个地方使用的对象，其它线程不能对它解锁，这个锁会被编译器优化掉。和没有syncronized代码块效果是相同的</div>
                            <span class="time">2019-03-05</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">实在是太厉害了！！！</p>
                                <p class="reply-time">2019-03-05</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqjceGMS81zZibA9LECsgAUU1aHPKhfM4WyNgqPtmnxvtzhC3a44ows3g7FuD7ibESAAY0UWsicW0EjA/132" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">王大王</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">19</span></a></div>
                            </div>
                            <div class="bd comment-content">Get方法加锁不是为了解决原子性问题，这个读操作本身就是原子性的，是为了实现不能线程间addone方法的操作结果对get方法可见，那么value变量加volitile也可以实现同样效果吗？</div>
                            <span class="time">2019-03-05</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">是的，并发包里的原子类都是靠它实现的</p>
                                <p class="reply-time">2019-03-05</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="http://thirdwx.qlogo.cn/mmopen/vi_32/4QtlO84mT9kcRmeglzXJxM31KiboYG3lIiaYXqKODYH0iaHdQibrwiaAhyUxIedjOliaXOP8pq7k6XZWFeiamGa6u6IOw/132" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">大南瓜</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">8</span></a></div>
                            </div>
                            <div class="bd comment-content">沙发，并不能，不是同一把锁</div>
                            <span class="time">2019-03-05</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">为快点赞</p>
                                <p class="reply-time">2019-03-05</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">石头剪刀布</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">7</span></a></div>
                            </div>
                            <div class="bd comment-content">老师说：现实世界里，我们可以用多把锁来保护同一个资源，但在并发领域是不行的。<br>不能用两把锁锁定同一个资源吗？<br>如下代码：<br>public class X {<br>    private Object lock1 = new Object();<br>    private Object lock2 = new Object();<br>    private int value = 0;<br><br>    private void addOne() {<br>        synchronized (lock1) {<br>            synchronized (lock2) {<br>                value += 1;<br>            }<br>        }<br>    }<br><br>    private int get() {<br>        synchronized (lock1) {<br>            synchronized (lock2) {<br>                return value;<br>            }<br>        }<br>    }<br>}<br><br>虽然说这样做没有实际意义，但是也不会导致死锁或者其他不好的结果吧？请老师指导，谢谢。<br></div>
                            <span class="time">2019-03-08</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">你这么优秀，我该怎么指导呢？你这不是用lock1 保护 lock2，lock2保护value吗？很符合我们的原则。我怎么没想到呢？<br></p>
                                <p class="reply-time">2019-03-09</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/12/5d/cb/9acac92c.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">sbwei🚴</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">6</span></a></div>
                            </div>
                            <div class="bd comment-content">最后的思考题: 多把锁保护同一个资源，就像一个厕所坑位，有N多门可以进去，没有丝毫保护效果，管理员一看，还不如把门都撤了，弄成开放式(编译器代码优化)😂。</div>
                            <span class="time">2019-03-24</span>
                            
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/12/61/94/713b38ef.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">小和尚笨南北</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">6</span></a></div>
                            </div>
                            <div class="bd comment-content">不正确<br>使用锁保护资源时，对资源的所有操作应该使用同一个锁，这样才能起到保护的作用。<br>课后题中每个线程对资源的操作都是用的是各自的锁，不存在互斥和竞争的情况。<br>这就相当于有一个房间，每个人过来都安装一个门，每个人都有自己门的钥匙，大家都可以随意出入这个房间。<br>由于每个线程都可以随时进入方法，所以存在原子性问题；<br>但是因为每次都有加锁和解锁的操作，unlock操作会使其他缓存的变量失效，需要重新从主内存中加载变量的值，所以可以解决可见性问题。<br>如有错误，请老师指正。</div>
                            <span class="time">2019-03-05</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">比喻很生动</p>
                                <p class="reply-time">2019-03-06</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/13/4c/c0/f5b54f74.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">落落彩虹</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">4</span></a></div>
                            </div>
                            <div class="bd comment-content">老师的文章我都要看几遍.评论区也不敢放过.<br><br>评论区有些demo，注意关于join的hb原则；注意system.out.println对可见性的影响，该方法内部加锁了.<br>还有个问题，如果我不用join，而是sleep足够长时间以确保线程跑完了，也能保证可见性.因为线程结束了他的本地工作空间该释放了，数据要强制刷回内存了……这也可以认为是join的hb原则吗？我看网上说到hb都会把join的那个原则说成是线程终止规则.<br></div>
                            <span class="time">2019-03-10</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">感谢不离不弃啊<br>测试的时候经常用sleep，实际项目还是用join吧。这个我感觉不能认为是join原则。规范里确实没有。</p>
                                <p class="reply-time">2019-03-10</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/11/f7/0a/067537fc.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">别皱眉</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">3</span></a></div>
                            </div>
                            <div class="bd comment-content">老师，我觉得get方法有必要用加锁来保证可见性的另一个理由如下:<br>class SafeCalc {<br>	long value = 0L;<br><br>	synchronized long get() {<br>		return value;<br>	}<br><br>	synchronized void add(int i) {<br>		// 业务代码....假如这里比较耗时<br>		value += i;<br>	}<br>}<br><br>假如线程A执行add方法 当方法还没执行完<br>线程B执行get方法 <br>如果get方法没有加锁 因为此时A正在修改这个数据  B获取的数据不是最新的 <br><br>您看我说的对吗？还是说具体场景有不同的需求，有些还是允许这点延迟的？<br>本人大三，请前辈多指教😁😁谢谢<br></div>
                            <span class="time">2019-03-13</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">我觉得你这个才是正道，并发问题小心还躲不过呢，哪里敢冒险啊！没想到还有学生看这个专栏，有前途👍<br><br></p>
                                <p class="reply-time">2019-03-13</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKtS26SJpSF7JLu9pusGsy1Qln0NdQg1eV2YKOJxpX2QXaBuuyXMqZY3fm0rhzKwsqN5aa6CVNOQQ/132" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">陈华</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">3</span></a></div>
                            </div>
                            <div class="bd comment-content">我理解get方法不需要加synchroized关键字，也可以保证可见性。<br>因为 对 value的写有被 synchroized 修饰，addOne（）方法结束后，会强制其他CPU缓存失效，从新从内存读取最新值！<br><br>class SafeCalc {<br>  long value = 0L;<br>  long get() {<br>    return value;<br>  }<br>  synchronized void addOne() {<br>    value += 1;<br>  }<br>}<br></div>
                            <span class="time">2019-03-07</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">你说的对，从实现上看是这样。但是hb没有这样的要求<br></p>
                                <p class="reply-time">2019-03-07</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/14/7a/14/1aeddf3a.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">churchchen</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">3</span></a></div>
                            </div>
                            <div class="bd comment-content">class SafeCalc {<br>  static long value = 0L;<br>  synchronized long get() {<br>    return value;<br>  }<br>  synchronized static void addOne() {<br>    value += 1;<br>  }<br>}<br><br><br>get()方法的可见性不太理解为什么不能保证</div>
                            <span class="time">2019-03-06</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">get和addone锁的是一个对象，结合上一期的hb规则再想想<br></p>
                                <p class="reply-time">2019-03-07</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/12/99/2c/faadcfbc.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">ChallengeND</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">3</span></a></div>
                            </div>
                            <div class="bd comment-content">synchronized的加锁解锁，具体是怎么实现的，没有讲</div>
                            <span class="time">2019-03-05</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">有兴趣的自己找资料看吧</p>
                                <p class="reply-time">2019-03-05</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">侯大虎</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">2</span></a></div>
                            </div>
                            <div class="bd comment-content">老师，有个小问题  class锁锁的是该类的所有实例，和this不应该是同一把锁吗(this不就是这个类的实例吗)？</div>
                            <span class="time">2019-03-30</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">没有包含关系，就像公交卡和单次票一样，都能坐车<br></p>
                                <p class="reply-time">2019-03-31</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/13/0d/29/18272af9.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">hxy</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">2</span></a></div>
                            </div>
                            <div class="bd comment-content">老师请问synchronized修饰的临界区中，如果不是同一把锁，能保证共享变量的可见性吗？<br>    private final static int cnt = 10000;<br>    private static int tmp = 0;<br><br>    public static void main(String[] args) {<br><br>        Object lock1 = new Object();<br>        Object lock2 = new Object();<br><br>        Thread thread1 = new Thread(() -&gt; {<br>            synchronized (lock1) {<br>                for (int i = 0; i &lt; cnt; i++) {<br>                    tmp++;<br>                }<br>            }<br>        });<br>        Thread thread2 = new Thread(() -&gt; {<br>            Watch.slp(10L);<br>            synchronized (lock2) {<br>                System.out.println("tmp is: " + tmp);<br>            }<br>        });<br><br>        thread2.start();<br>        thread1.start();<br>    }<br>我这样试了一下，thread2最后读的值是正确的，感觉有一点奇怪</div>
                            <span class="time">2019-03-06</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">这种简单情况，实际上出bug的概率还真是很低。但是低不意味着正确。<br>也不用奇怪，我们所说的都是可能。锁两个对象，编译器官方不保证可见性，私下里也许能保证。我们不能依赖于私下的方案。</p>
                                <p class="reply-time">2019-03-06</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/10/04/ef/fea0fdbd.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">小黄</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">2</span></a></div>
                            </div>
                            <div class="bd comment-content">明显getOne 和 addOne 每次加锁在不同资源上，并没有形成互斥</div>
                            <span class="time">2019-03-05</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">👍<br></p>
                                <p class="reply-time">2019-03-05</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/15/af/76/feaffdea.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">彻头撤尾</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">1</span></a></div>
                            </div>
                            <div class="bd comment-content">别皱眉同学,我特意把你的代码考下来了,run方法里什么都不加 就是死循环,加一个变量b==2作为循环出口,线程b也可以正常退出的啊!!!!线程可见性问题应该描述的是变量被修改的这一瞬间其他线程可见性问题吧?你加不加打印语句,加不加同步代码块都不会影响线程b的正常结束吧?只要变量最新值刷到主内存中,线程b 就可见然后就终止了.</div>
                            <span class="time">2019-03-31</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">感谢热心同学的回复！！</p>
                                <p class="reply-time">2019-03-31</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/12/e7/50/d476ed6c.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">Mr.Panda</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">1</span></a></div>
                            </div>
                            <div class="bd comment-content">老师您好，望答疑<br>概念：“同一时刻只有一个线程执行”这个条件非常重要，我们称之为互斥<br>疑惑:  一段关注代码(多个操作指令)只能由个一个线程执行，就算中间发生线程切换，其他线程也不能执行这段代码，才叫互斥吧 <br></div>
                            <span class="time">2019-03-31</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">你说的是对的，而且更严谨。但是站在应用的角度，一般都忽略掉这些细节，这样在大脑里推演程序的执行会更容易。</p>
                                <p class="reply-time">2019-03-31</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/11/fd/dd/baeda83e.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">Monster!</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">1</span></a></div>
                            </div>
                            <div class="bd comment-content"> private volatile Long count = 0L;<br>    private  void add(){<br>        int add = 0;<br>        while (add++&lt;10000){<br>            count ++;<br>        }<br>    }<br>    public static Long calc() throws InterruptedException {<br>        ThreadCountTest threadCountTest = new ThreadCountTest();<br>        Thread thread1 = new Thread(()-&gt;{<br>            threadCountTest.add();<br>        });<br>        Thread thread2 = new Thread(() -&gt; {<br>            threadCountTest.add();<br>        });<br>        //开启两个线程<br>        thread1.start();<br>        thread2.start();<br>        //等待两个线程结束<br>        /*thread1.join();<br>        thread2.join();*/<br><br>        return threadCountTest.count;<br>    }<br>王老师，请教一下，根据上一节的思考题，如果要想让线程A对共享资源的修改对线程B可见其中一种方法就是在共享变量上加volatile关键字，如上述代码在注释掉两个方法的join()时得出的结果为0，放开两个join()方法后得出的结果又是随机的，这个问题出在哪里呢？</div>
                            <span class="time">2019-03-28</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">那两个线程还没来得及跑，主线程执行到return threadCountTest.count;了</p>
                                <p class="reply-time">2019-03-28</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/11/f7/0a/067537fc.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">别皱眉</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">1</span></a></div>
                            </div>
                            <div class="bd comment-content">相信很多人跟我一样会碰到这个问题,评论里也看到有人在问，内容有点长，辛苦老师帮忙大家分析下了 哈哈<br>&nbsp;&nbsp;---------------------------------------------------------<br>public class A implements Runnable {<br>&nbsp;&nbsp;&nbsp; public Integer b = 1;<br>&nbsp;<br>&nbsp;&nbsp;&nbsp; @Override<br>&nbsp;&nbsp;&nbsp; public void run() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("A is begin!");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (true) {<br>               System.out.println("a");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // System.out.println(b);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (b.equals(2))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("A is finish!");<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;<br>&nbsp;&nbsp;&nbsp; public static void main(String[] args) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A a = new A();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //线程A<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Thread(a).start();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Thread.sleep(1000);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } catch (InterruptedException e) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e.printStackTrace();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a.b = 2;<br>&nbsp;&nbsp;&nbsp; }<br>}<br>&nbsp;<br>我们知道这个程序会出现可见性问题。<br>但是在while内加上System.out.println(b)后 当主线程修改b的值后 线程A居然能够取得最新值 可见性问题得到解决<br>System.out.println(b)的实现如下<br>&nbsp;&nbsp;&nbsp; public void println(String x) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; synchronized (this) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print(x);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; newLine();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;<br>Doug Lea大神的Concurrent Programming in Java一书中有这样一个片段来描述synchronized这个关键字：<br>&nbsp;<br>这里英文就不放出来了 字数超过两千……<br>这篇文章也有提及https://www.jianshu.com/p/3c06ffbf0d52<br>&nbsp;<br>简单翻译一下：从本质上来说，当线程释放一个锁时会强制性的将工作内存中之前所有的写操作都刷新到主内存中去，而获取一个锁则会强制性的加载可访问到的值到线程工作内存中来。虽然锁操作只对同步方法和同步代码块这一块起到作用，但是影响的却是线程执行操作所使用的所有字段。<br><br><br>也就是说当调用System.out.println("a")时当前线程的缓存会被重新刷新过，所以才能够读到这个值最新值<br>&nbsp;---------------------------------------------------------<br>然后问题来了<br>问题1:<br>首先上面的说法不知道是不是真的是这样。<br>然后我在下面加了System.out.println(b) 结果打印出来的是旧值，但是下面的b.equals(2)却能通过 这里没弄明白 我觉得应该是编译器进行了优化?因为现在大三能力不够，还没学会看class文件 没法验证<br>&nbsp;<br>问题2:<br>网上找了一些文章<br>有些人的说法是：打印是IO操作，而IO操作会引起线程的切换，线程切换会导致线程原本的缓存失效，从而也会读取到修改后的值。<br>&nbsp;<br>我尝试着将打印换成File file = new File("D://1.txt");这句代码，程序也能够正常的结束。当然，在这里也可以尝试将将打印替换成synchronized(A.class){ }这句空同步代码块，发现程序也能够正常结束。<br>&nbsp;<br>这里有个问题就是 线程切换时会把之前操作的相关数据保存到内存里，切换回来后会把内存里的数据重新加载到寄存器里吗，这样说的话 就算切换也是获取不到修改后的值的,不知道是什么做到能够读到这个修改后的值的？<br>&nbsp;<br>问题3:<br>是不是<br>线程执行过程中，操作系统会随机性的把缓存刷到内存<br>线程结束后一定会把缓存里的数据刷到内存<br><br>&nbsp;---------------------------------------------------------<br>在评论里好多大神 能学到好多东西😄😄</div>
                            <span class="time">2019-03-17</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">1. println的代码里锁的this指的是你的控制台，这个锁跟你的代码没关系，而且println里也没有写操作，所以println不会导致强刷缓存。<br><br>我觉得是因为println产生了IO，IO相对CPU来说，太慢，所以这个期间大概率的会把缓存的值写入内存。也有可能这个线程被调度到了其他的CPU上，压根没有缓存，所以只能从内存取数。你调用sleep，效果应该也差不多。<br><br>2. 线程切换显然不足以保证可见性，保证的可见性只能靠hb规则。<br><br>3. 线程结束后，不一定会强刷缓存。否则Join的规则就没必要了<br><br>并发问题本来就是小概率的事件，尤其有了IO操作之后，概率就更低了。</p>
                                <p class="reply-time">2019-03-17</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/11/f7/0a/067537fc.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">别皱眉</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">1</span></a></div>
                            </div>
                            <div class="bd comment-content">老师，我对您对成华的回答有点疑问<br><br>------------------------------------------------------------<br>陈华:<br>我理解get方法不需要加synchroized关键字，也可以保证可见性。<br>因为 对 value的写有被 synchroized 修饰，addOne（）方法结束后，会强制其他CPU缓存失效，从新从内存读取最新值！<br>&nbsp;<br>class SafeCalc {<br>long value = 0L;<br>long get() {<br>return value;<br>}<br>synchronized void addOne() {<br>value += 1;<br>}<br>}<br>2019-03-07作者回复 说的对，从实现上看是这样。但是hb没有这样的要求<br><br>------------------------------------------------------------<br>会强制其他CPU缓存失效，从新从内存读取最新值？如果陈华说的是正确的，那get方法就不用加synchronized就可以保证可见性了？<br><br>但您文章里说的是get方法不加锁可见性是无法保证的<br><br><br></div>
                            <span class="time">2019-03-13</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">按照规范是不能保证的，具体实现现在可以，这两个不矛盾，但是我们不能依赖没有承诺的实现，它可以随时改，规范就不可以随时改。<br>我们这里就采取遵循规范。</p>
                                <p class="reply-time">2019-03-13</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/16/1b/2c/6b3c0911.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">Hour</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">1</span></a></div>
                            </div>
                            <div class="bd comment-content">文末的case是存在并发问题的，评论区里回复的很细了，就不再赘述。<br><br>不过我有个疑问，望老师能指导下:<br><br>sync可以对"变量"加锁，也可以对"对象"加锁，还可以对"类"加锁，但一直没理解对"类"加锁的意义是什么，凡是可以用"类"加锁的地方，都可以用"变量锁"、"对象锁"替换，"对象锁"在对象维度加锁，而"变量锁"是在更细粒度加锁，但"类锁"却不是在更大维度加锁，那"类锁"的意义在哪里？</div>
                            <span class="time">2019-03-08</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">其实都是对对象加锁，只是静态方法要用静态对象。语法上用类加锁只是使用简单而已</p>
                                <p class="reply-time">2019-03-08</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/12/df/1c/70d51b43.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">毛祥</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">1</span></a></div>
                            </div>
                            <div class="bd comment-content">线程每次调用方法锁的都是新new的一个对象。令哥讲解得透彻，让我这个菜鸟一看code就知道答案。此外，留言板潜伏一樽樽大神，有种豁然开朗的感觉。</div>
                            <span class="time">2019-03-07</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">你也会成为一尊大神的<br></p>
                                <p class="reply-time">2019-03-07</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/14/e1/ca/a41422f6.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">橘子</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">1</span></a></div>
                            </div>
                            <div class="bd comment-content">set和get都对同一个对象加锁，时候意味着，在并发情况下，get和set不能同时被调用，在同一时间只能调用一个？</div>
                            <span class="time">2019-03-06</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">是的</p>
                                <p class="reply-time">2019-03-06</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/15/fe/66/1b8b8c09.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">　　　　　　　　</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">1</span></a></div>
                            </div>
                            <div class="bd comment-content">课后思考题：加锁方式不正确。首先是保护的资源是不对的，每次都是新对象；其次两个sync 锁住的资源也是不同的。原子性问题和可见性问题都没有办法解决。</div>
                            <span class="time">2019-03-06</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">正确<br></p>
                                <p class="reply-time">2019-03-06</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/15/f8/fd/45b31832.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">「」Resolution</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">1</span></a></div>
                            </div>
                            <div class="bd comment-content">锁定不同的资源， 导致无法解决可见性的问题， 并且无法形成互斥关系，无法保证原子性问题</div>
                            <span class="time">2019-03-05</span>
                            
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erWxMXolPylQk8Z6V6yt2LtibksrksC4bHtmxkuCC4Wzw7trl6CfwmsSFMyHFItFnvl21RvQ8fyOBQ/132" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">Geek_961eed</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">1</span></a></div>
                            </div>
                            <div class="bd comment-content">想问下作者，类锁和对象实例锁之间有什么联系？</div>
                            <span class="time">2019-03-05</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">平行关系，中国和美国之间的关系。</p>
                                <p class="reply-time">2019-03-05</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqjceGMS81zZibA9LECsgAUU1aHPKhfM4WyNgqPtmnxvtzhC3a44ows3g7FuD7ibESAAY0UWsicW0EjA/132" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">王大王</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">1</span></a></div>
                            </div>
                            <div class="bd comment-content">管程锁规则和连续性规则一结合，可以实现对同一个锁保护的资源间实现可见性，真是太奥妙了</div>
                            <span class="time">2019-03-05</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">所以后来c#,c++都开始搞内存模型了</p>
                                <p class="reply-time">2019-03-05</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/11/a2/f3/aa504fa6.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">波波</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">1</span></a></div>
                            </div>
                            <div class="bd comment-content">这一节锁讲的有新意，很少有书籍特地讲锁和锁定资源的关系，赞一个</div>
                            <span class="time">2019-03-05</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">我还是觉得内存模型讲的最好;)，以后的东西都很简单了</p>
                                <p class="reply-time">2019-03-05</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/10/e4/76/a97242c0.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">黄朋飞</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">1</span></a></div>
                            </div>
                            <div class="bd comment-content">老师你好，能解释下get方法不加锁为什么可见性没法保证吗？没看懂</div>
                            <span class="time">2019-03-05</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">你可以想象成是缓存的原因<br></p>
                                <p class="reply-time">2019-03-05</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/0f/ae/d6/6eeb7075.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">计科一班</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">1</span></a></div>
                            </div>
                            <div class="bd comment-content">锁定的不是同一个对象</div>
                            <span class="time">2019-03-05</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">不仅仅这样，你也再想想</p>
                                <p class="reply-time">2019-03-05</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/12/da/ec/779c1a78.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">往事随风，顺其自然</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">1</span></a></div>
                            </div>
                            <div class="bd comment-content">两个方法都是new 出来的，是不同对象，读写不在同一把锁当中，并不能保证满足happen-before 原则，写发生在读操作之前，可以改为同一个对像的锁或者是同一个类锁</div>
                            <span class="time">2019-03-05</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">不仅仅是这样。你也再想想</p>
                                <p class="reply-time">2019-03-05</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/12/d0/03/2e632d36.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">Geek_c42505</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">1</span></a></div>
                            </div>
                            <div class="bd comment-content">synchronized 作用于非静态方法上，加锁对象是当前对象，代码中new Object 作为锁，两个方法使用两个不同的锁保护同一个资源，是不能解决并发问题的</div>
                            <span class="time">2019-03-05</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">实际上每次调用都创建新的锁，相当于没有锁。</p>
                                <p class="reply-time">2019-03-05</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/10/fd/d6/71e1cc29.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">Kaer</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">1</span></a></div>
                            </div>
                            <div class="bd comment-content">老师，对于最后的锁定Safecalc.class和this不是一把锁有点疑问。都锁定了class了，在我理解这个时候this也应该是锁定的。这么说的话应该就是互斥的了。换一个角度理解：就是我把大门锁定了，房间肯定进不去，虽然不是一把锁，但是我觉得应该能保证互斥。</div>
                            <span class="time">2019-03-05</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">不是这样的。Safecalc.class是一个对象，this也是一个对象。他们是平级的。<br></p>
                                <p class="reply-time">2019-03-05</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/10/d8/d6/47da34bf.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">任鹏斌</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">1</span></a></div>
                            </div>
                            <div class="bd comment-content">锁定的是不同对象，相当于为不同的资源加锁，不能解决并发问题</div>
                            <span class="time">2019-03-05</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">每次调用都创建一把锁，其实相当于没有加锁。编译器优化后，就变成无锁了</p>
                                <p class="reply-time">2019-03-05</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">宝爸学学学</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">我觉得评论区学到的更多啊，你们真的是来学习的吗 :D</div>
                            <span class="time">2019-05-15</span>
                            
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/15/e6/02/65a764fe.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">Michael</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">老师，例子中说synchronized用于保证操作的原子性，如果get方法没有synchronized的话不能保证可见性，下面的代码模拟了多线程操作addOne方法，但是get方法上有没有synchronized结果都是正确的。为什么没有出现可见性问题呢？<br>public class Test {<br><br>  private long c = 0;<br><br>  //getC方法有没有synchronized运行结果都一样<br>  public long getC() {<br>    return c;<br>  }<br><br>  public synchronized void addOne() {<br>    c += 1;<br>    //为了模拟长时间处理<br>    long i = 0;<br>    while (i &lt; 100000000L) {<br>      i++;<br>    }<br>  }<br><br>  public static void main(String[] args) throws InterruptedException {<br>    Test test = new Test();<br><br>    //每个线程都加10<br>    Thread t1 = new Thread(()-&gt;{<br>      for (int i = 0; i &lt; 10; i++) {<br>        test.addOne();<br>      }<br>    });<br>    Thread t2 = new Thread(()-&gt;{<br>      for (int i = 0; i &lt; 10; i++) {<br>        test.addOne();<br>      }<br>    });<br>    Thread t3 = new Thread(()-&gt;{<br>      for (int i = 0; i &lt; 10; i++) {<br>        test.addOne();<br>      }<br>    });<br>    t1.start();<br>    t2.start();<br>    t3.start();<br><br>    t1.join();<br>    t2.join();<br>    t3.join();<br><br>    System.out.println(test.getC());<br>  }<br>}<br></div>
                            <span class="time">2019-05-14</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">第一章说的双重检查的例子，也很难重现，但理论上还是会出问题。比较靠谱的方法是内存模型推断不出来的，就认为有问题。当然这个条件更严格，有些不符合的，也没问题。你这个例子用了join，属于可以推导出来没问题的</p>
                                <p class="reply-time">2019-05-14</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/10/d4/ec/804c3900.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">Niuniu</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">别皱眉同学的问题，关于是不是触发IO导致内存刷新，可以很容易验证。把class A里面所有上的System.out.println命令全部comment out，再run一遍，会发现程序进入死循环。没有system.out。println，没触发io，所以内存没有刷新。</div>
                            <span class="time">2019-05-06</span>
                            
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/11/2a/54/c9990105.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">bro.</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">不可以,相当于什么都没做,每次进来new object就相当于创建一把新锁,跟其他线程完全无关,所有锁都是一次性的,可以new object()作为全局变量引用即可</div>
                            <span class="time">2019-04-26</span>
                            
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/0f/a1/e6/50da1b2d.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">旭东</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">互斥锁，一定要锁同一对象。否则形同虚设</div>
                            <span class="time">2019-04-24</span>
                            
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/11/fb/6a/be4956a3.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">劉小强</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">为什么get方法要加synchronized修饰  一个线程执行add方法还没执行完的时候，调用get方法显示没有+1后的值不是应该是正确的么，加上这个synchronized的必要性是什么？没有理解</div>
                            <span class="time">2019-04-22</span>
                            
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/0f/ae/00/025f37e7.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">xuery</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">这一节其实就是hb的规则4，通过这么一讲解，理解的更深刻了</div>
                            <span class="time">2019-04-18</span>
                            
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/0f/ae/00/025f37e7.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">xuery</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">不正确。每次加的都是不同的锁，起不到互斥的作用</div>
                            <span class="time">2019-04-18</span>
                            
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/11/0b/f1/042df911.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">qzm</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">回答下问题：无法解决可见性跟原子性。原因是synchronized的加锁的资源(即监视器)不是同一个！故就无法互斥。</div>
                            <span class="time">2019-04-17</span>
                            
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/13/e1/5c/b32f00b1.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">Richard</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">如果只是为了可见性的问题，是否可以在add方法上加锁，把value声明为volatile，而get方法不加锁。这样效率是不是会高一些啊。</div>
                            <span class="time">2019-04-15</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">如果只需要可见性volatile就够了<br></p>
                                <p class="reply-time">2019-04-16</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLjrPm3HE2KwDa5zGK5N77KZwJEnPU5lgVhKuZicvQ1nL2iad92uetnCmdgIIxeCdu8lhoQ0w5uWEHA/132" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">Geek_9621ee</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">您好，我上次请教:synchronized 块中的代码为什么会发生线程切换，如果发生线程切换还如何保证原子性，您说 “原子性和线程切换没有什么关系，os想多会儿切换就多会切换”，但是我在今天的课中看到：“你已经知道，原子性问题的源头是线程切换，如果能够禁用线程切换那不就能解决这个问题了吗？而操作系统做线程切换是依赖 CPU 中断的，所以禁止 CPU 发生中断就能够禁止线程切换。”这是不是有点矛盾呢？</div>
                            <span class="time">2019-04-15</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">os的特权指令，可以关中断。但是普通的进程是做不到的。如果搞os可以，因为os是上帝。如果是普通人，想让自己长生不老，上帝不会答应的。所以看你站在哪个角度看待这个问题</p>
                                <p class="reply-time">2019-04-15</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/0f/fe/ea/d8b1909e.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">刘梦茹</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">两把锁保护同一个资源value，这两把锁，锁定的对象是两个不同的Object实例，临界区get()和addOne()不具有互斥性，因此不保证可见性。</div>
                            <span class="time">2019-04-14</span>
                            
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/12/f3/58/1ef2fa55.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">90飞</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">为啥会被编译器优化掉？</div>
                            <span class="time">2019-04-12</span>
                            
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/11/4c/86/3be94807.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">angel😇txy🤓</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">高手太多</div>
                            <span class="time">2019-04-12</span>
                            
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/11/52/37/13b4c8aa.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">Vincent</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">同一个时刻只有一个线程执行临界区代码，是互斥的唯一条件</div>
                            <span class="time">2019-04-11</span>
                            
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/10/e0/24/4529f2a4.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">WP</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">每篇文章看完之后，再回来看融会贯通，很多都串起来了，哈哈，老师优秀</div>
                            <span class="time">2019-04-04</span>
                            
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/11/52/37/13b4c8aa.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">Vincent</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">课后习题因为每个方法使用不同的锁，不能达到互斥的效果，不能解决原子性问题，sync同步关键字，线程对sync锁的解锁happen-before于后续线程对sync的加锁，可见性问题可以解决。<br><br>但是有一个小问题就是sync使用的是两个不同的锁，happen-before规则对于这种情况还有效？</div>
                            <span class="time">2019-04-03</span>
                            
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/11/52/37/13b4c8aa.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">Vincent</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">get()方法为了可见性有必要给他加一把锁？用volatile关键字修饰变量也可以啊</div>
                            <span class="time">2019-04-02</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">可以<br></p>
                                <p class="reply-time">2019-04-02</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/0f/a3/8b/080d337e.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">燕青兄弟</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">先给结果：get() 和andOne()这2个方法，都不能解决可见性和原子性问题。<br>再来具体分析：synchronized代码块中，加的锁是new的一个Object，这个锁本身和资源没啥关系，所以无法起到加锁的效果。而且每次都是new Object(),这样每次进入方法时，这个锁都不一样，更加不能起到任何作用。</div>
                            <span class="time">2019-04-01</span>
                            
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/15/af/76/feaffdea.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">彻头撤尾</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">class X {<br>  // 修饰代码块<br>  Object obj = new Object()；<br>  void baz() {<br>    synchronized(obj) {<br>      // 临界区<br>    }<br>  }<br>}  <br>请问王老师,这种成员变量作为锁对象 是不是只能保证锁住同一个实例的资源,不同的实例的锁不同,不存在互斥关系?然后,这种成员变量作为锁对象和this关键字作为锁对象有什么区别么?</div>
                            <span class="time">2019-03-31</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">1. 只能保证锁住同一个实例的资源，不同的实例的锁不同,不存在互斥<br>2. 锁隐藏在对象内部，更安全。</p>
                                <p class="reply-time">2019-03-31</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/12/e7/50/d476ed6c.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">Mr.Panda</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">老师好，对这个概念有点疑惑，请指导。<br>概念：“一个或者多个操作在 CPU 执行的过程中不被中断的特性，称为原子性”<br>疑惑：<br>1.互斥锁后，临界区的代码执行过程中不是依然会发生cpu中断导致线程切换吗？<br>2.个人理解，原子性应该是保证相关代码的执行者由原来可以多个线程执行改为只能由一个线程执行且执行完，其他线程才有机会去执行。</div>
                            <span class="time">2019-03-31</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">1. 互斥锁后，依然不能阻止CPU进行线程<br>2. 原子性有很多层面的理解，指令层面有，高级语言层面有，数据库层面还有。在不同的上下文中能领会到就可以，概念是为了解决问题的，所以也要看场景。更哲学的说法，下一章会介绍。</p>
                                <p class="reply-time">2019-03-31</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/10/9a/01/1489f98d.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">^_^</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">new Object()每次调用返回的是对象的引用，地址不一样，用在上面的代码中，就会出现两把锁锁同一个资源的问题，好比球场中同一个座位票重了</div>
                            <span class="time">2019-03-30</span>
                            
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/11/fd/dd/baeda83e.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">Monster!</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">老师，您刚才给我回复说，两个线程还没来得及跑已经执行return语句了，但是我刚才试了下，在return前Thread.sleep(10000)然后结果不是0了，结果为一万多的随机数，还有就是我就算不用hread.sleep(10000)方法，而是用thread1.join();thread2.join()，讲道理应该是等两个线程都结束了再返回值，期望值是20000，但结果还是一万多的随机数，想不明白啊，老师求救</div>
                            <span class="time">2019-03-28</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">看不到你的源码了，应该是有并发问题了，你的期望需要正确的同步<br></p>
                                <p class="reply-time">2019-03-29</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/11/52/37/13b4c8aa.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">Vincent</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">SafeCalc中get方法本质就是期望可见性，不用sync关键字用volatile关键字修饰变量可以吗？</div>
                            <span class="time">2019-03-26</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">不可以，本质是竞态条件问题<br></p>
                                <p class="reply-time">2019-03-26</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/16/7c/b5/4a7a2bd4.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">Sunqc</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">老师总结的好啊，一针见血，很好理解</div>
                            <span class="time">2019-03-25</span>
                            
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/11/52/37/13b4c8aa.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">Vincent</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">synchronized 案例中锁是synchronized，锁定对象是this或者 XXX.class 这里来看，我们的锁结构是synchronized，锁定的资源是对应的this和 XXX.class，在文中作者特意区分锁结构和被保护的资源是很好的一点，但是行文中并没有特意去说明谁是锁结构，谁是被保护资源</div>
                            <span class="time">2019-03-25</span>
                            
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/12/e8/dc/32e78f02.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">乐凡</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">不能，两个方法的锁不是同一个对象。也就是不是同一把锁</div>
                            <span class="time">2019-03-24</span>
                            
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/11/03/55/b29961a8.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">谢晓飞</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">老师你好，我想问下怎么看java优化后的代码</div>
                            <span class="time">2019-03-22</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">有些可以看汇编，有些看不到，虚拟机和cpu都会在运行时都会优化<br></p>
                                <p class="reply-time">2019-03-22</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/0f/42/76/abb7bfe3.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">松花皮蛋me</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">逃逸分析后因为new object()其他线程永远访问不到，编译化优化成非锁了</div>
                            <span class="time">2019-03-19</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">正解<br></p>
                                <p class="reply-time">2019-03-19</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/11/15/69/fc60d1f4.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">陈华应</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">不正确<br>1、每次创建的保护资源的锁都是一把新的锁，没有起到作用反而额外增加了加锁、解锁的开销<br>2、可见性没有保证，根据Happens-Before规则，get和set之间没有任何关系并且没有通过同一把锁串行化<br>3、原子性没有保证，对于value+=1操作是非原子性的，并且锁对象对于每个线程都是新的，也就是仍然会有多个线程同时执行value+=1操作<br>分析问题还是要尝试通过JMM和加锁规则来分析，用什么锁来保护什么</div>
                            <span class="time">2019-03-18</span>
                            
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/11/f7/0a/067537fc.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">别皱眉</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">老师，我有几个问题比较疑惑😄<br>---------------------------------------------<br>问题1: <br>synchronized void test() {<br>        //操作1<br>        value = value + 1;<br>         //业务方法....<br>        //操作2<br>         value = value + 2;<br>  }<br>为保证原子性，也就是value中间状态对外不可见，我觉得操作1完成后不会将最新值刷回内存,而是到解锁后才会将在synchronized块中操作的数据刷回内存！<br> --------------------------------------------------<br>问题2：<br>有些同学说将value变量加volitile也可以实现同样效果.<br>我觉得不行，可见性保证了，原子性却会被破坏。理由如下:<br>基于问题1，假设操作1完成后不会将最新值刷回内存，那如果此时value变量加volitile上后，操作1完成后那岂不是会将这个中间值value存入内存?如果真是这样，原子性是保证不了的。<br> ----------------------------------------------------<br>问题3:<br>volatile int x = 0：告诉编译器，对这个变量的读写，不能使用 CPU 缓存，必须从内存中读取或者写入。<br> <br>Synchronized即保证可见性，又保证原子性。<br>那要保证可见性，在Synchronized块中是不是第一次读取到变量value时将直接从内存读，解锁时，将最新值刷回内存。<br><br><br>希望老师帮忙分析下 谢谢🙏🙏🙏</div>
                            <span class="time">2019-03-17</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">1. synchronized 能保证互斥，所以操作1完成后刷入内存也没问题。如果你同步代码块里要操作10亿个共享变量，它不放内存放哪里呢？缓存早就爆表了。<br>2. 同意<br>3. 同意，另外volatile还会遵循hb规则。Synchronized解锁后会强刷缓存。</p>
                                <p class="reply-time">2019-03-17</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/12/f8/c3/1d557354.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">o my love</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">感觉好多大佬</div>
                            <span class="time">2019-03-15</span>
                            
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/16/1c/d5/248a9c38.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">你只是看起来很努力</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">老师，我实现三个线程操作一个共享变量i，然后这个这个i做为循环条件去控制我在run()方法写的输出语句（并打印共享变量i的值），可是我这个地方i竟然可以打印到11，后来我发现是加了volatile的问题，请问除了在循环里面再加个判断还有别的方法来实现三个线程循环打印这条输出语句吗？<br>package com.cn.join;<br>/**<br> * 继承Thread类实现多线程<br> * @author HP<br> *<br> */<br>public class MyThread extends Thread {<br>	private volatile static int i = 0;<br>	public MyThread() {<br>		super();<br>	}<br>	@Override<br>	public void run() {<br>		// TODO Auto-generated method stub<br>		super.run();<br>		/*synchronized(MyThread.class){for(;i&lt;10;i++){<br>			System.out.println(Thread.currentThread()+":"+i);<br>		}}*/<br>		while(i&lt;10){<br>			synchronized(MyThread.class){<br>				System.out.println(Thread.currentThread()+":"+i);<br>				i++;<br>			}<br>		}<br>	}<br>	public static void main(String[] args) {<br>		MyThread myThread1= new MyThread();<br>		MyThread myThread2= new MyThread();<br>		MyThread myThread3= new MyThread();<br>		myThread1.start();<br>		myThread2.start();<br>		myThread3.start();<br>	}<br>}<br></div>
                            <span class="time">2019-03-15</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">可以用条件变量来搞定，后面有介绍</p>
                                <p class="reply-time">2019-03-15</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/12/6e/3b/88f14e2a.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">PK時頭髮不亂</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">1. synchronized method(){....}<br>2. method(){<br>     synchronized(this){....}<br>  }<br>王老师, 没想明白, 这两个有什么区别呀？通常别人都是说粒度不一样, 可看了这篇后, 第1个所保护的资源是this 实例, 但2中也是保护 this 实例呀，请求解。。。谢谢</div>
                            <span class="time">2019-03-15</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">没区别<br></p>
                                <p class="reply-time">2019-03-15</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/11/f7/0a/067537fc.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">别皱眉</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">老师 还有个问题 哈哈<br><br>------------------------------------------------------<br>class A{<br>	/*volatile*/ boolean running = true;<br>	public synchronized void m() {<br>		System.out.println("m start");<br>		while(running) {<br>			//为什么每次sleep的时候running不用   volatile关键字时被修改时其它线程就可以看见<br><br>			try {<br>				Thread.sleep(1000);<br>			} catch (InterruptedException e) {<br>				e.printStackTrace();<br>			}<br>		}	<br>		System.out.println("m end");<br>	}<br>}<br><br><br>public class Test12 {<br><br>	public static void main(String[] args) {<br>		A a = new A();<br>		<br>   //A线程<br>		new Thread(()-&gt;a.m()).start();<br>		<br>		try {<br>			Thread.sleep(2000);<br>		} catch (InterruptedException e) {<br>			e.printStackTrace();<br>		}<br>		a.running = false;<br>	}<br>}<br>------------------------------------------------------<br>这里的running没有用volatile修饰<br>在线程A调用m方法时 在while循环内每次都sleep两秒 <br>主线程sleep一秒后修改running为false<br>线程A对这次修改为可见<br><br>当把while循环的sleep去掉时<br>线程A对这次修改不可见<br><br>这是为什么呢？sleep时间到会让当前线程重新到内存取值？</div>
                            <span class="time">2019-03-13</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">sleep两秒，相当于cpu休息了十万八千年。我猜测cpu的缓存不会存这么久吧。</p>
                                <p class="reply-time">2019-03-13</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/10/94/47/75875257.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">虎虎❤️</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">请老师对我的理解进行指正：<br><br>锁和被保护资源的关系？<br><br>互斥锁锁住了一个代码段 除非获得互斥锁，否则其他的线程不能访问这段代码。 代码段中包含了对被保护资源的操作。<br>但是 这把锁似乎可以是任何的对象。 这个锁对象可以和被保护资源有或者没有任何包含关系。有包含关系的就是用this，<br>没有包含关系的情况比如：<br>public class DemoClass<br>{<br>    private final Object lock = new Object();<br>    public void demoMethod(){<br>        synchronized (lock)<br>        {<br>            //other thread safe code<br>        }<br>    }<br>}<br><br>对于class level的synchronized，我的理解是static变量属于类而被所有实例共用。所以用object.class这个对象作为锁非常合适。这也等价于<br>public class DemoClass<br>{<br>    private final static Object lock = new Object();<br> <br>    public void demoMethod()<br>    {<br>        //Lock object is static<br>        synchronized (lock)<br>        {<br>            //other thread safe code<br>        }<br>    }<br>}<br><br>然而用object.class作为锁来保护一个非静态资源就不太合适了。例如<br>class X {<br>  // 修饰静态方法<br>  synchronized(X.class) void bar() {<br>    // 临界区<br>  }<br>}<br>类的不同实例都可能来竞争这同一个锁，会导致并发程序非常低效。<br><br>另外，不要用String的字面量来作为锁，可能会被其他的对象引用，导致死锁。<br><br>不要用non-final的field来作为锁，non final的对象可能会随时被改变，而导致两个线程synchronize on different object。</div>
                            <span class="time">2019-03-13</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">总结的很对，👍👍👍<br></p>
                                <p class="reply-time">2019-03-13</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/15/23/a1/3de881a9.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">墨雨</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">class SafeCalc {<br>  static long value = 0L;<br>  synchronized static long get() {<br>    return value;<br>  }<br>  synchronized static void addOne() {<br>    value += 1;<br>  }<br>}<br>所以我在get方法上加static修饰这样是不是就是同一把锁了呢?(锁SafeCalc.Class),不知道这样理解是否正确</div>
                            <span class="time">2019-03-13</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">正确<br></p>
                                <p class="reply-time">2019-03-13</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/0f/96/63/fdbf75eb.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">捞鱼的搬砖奇</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">文中说get() addOne() 俩个方法互斥，如果多核心CPU，一个运行get() 一个运行addOne()呢？ 您是指在同个核心上吗？</div>
                            <span class="time">2019-03-12</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">没理解你的问题。互斥，不管几个cpu都只能一个线程执行<br></p>
                                <p class="reply-time">2019-03-13</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/16/26/95/a4e0f7ab.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">龙哥</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">共享资源是在SaftCalc内，需要对其加锁才能保证线程安全。所以这不是正确加锁</div>
                            <span class="time">2019-03-12</span>
                            
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="http://thirdwx.qlogo.cn/mmopen/vi_32/15WXictKcv02AGs8PPBGvykHg3tYc7Xb33xs0iayGLMIYdFhlPoHe0ABw5F93yyInM9D5nDSAU7TWwROz4rTk0YA/132" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">Tristan</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">get() 方法。执行 addOne() 方法后，value 的值对 get() 方法是可见的吗？<br>疑问：可不可以根据Happens-Before的第一个规则，将get（）方法调整到addOne（）方法后面，value的值对get（）方法就可见了，这样理解是否正确？ 他们都在主线程中，属不属于在同一个线程中？</div>
                            <span class="time">2019-03-12</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">如果两个方法都执行在一个线程里，当然没问题。<br>如果都在主线程，那就是一个线程。</p>
                                <p class="reply-time">2019-03-12</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epLhKkTgowm9PqUwP9k90DecpOU7HQ0IRuAp515kIonbfyqYm6ME7s2bmaPX0sSA14micZ2DAfLLibw/132" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">zsh0103</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">思考题中错误的使用了synchronzed，这里使用了两把锁，无法得到互拆的目的，因为new object() 为两个对，add方法的调用无法互拆get方法的调用，因此会出现读取旧值的情况。</div>
                            <span class="time">2019-03-11</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">是的，这种情况和没有锁是一样的</p>
                                <p class="reply-time">2019-03-11</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ernIGVtCQTwcxZlfvbj6PEOiaRuwysczZUGvQ3locPkE74bs140hTnwSCibHmpYvtaFJiaBnPiad1Gb1A/132" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">the only Mia’s</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">通过学习，明白了关于锁机制中很重要的一点是弄明白加锁的对象到底是什么，锁住的是同一个对象才会出现互斥的说法；</div>
                            <span class="time">2019-03-10</span>
                            
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">QQ怪</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">每次new都是一个新对象，不是同一把锁！这节课简单易懂，哈</div>
                            <span class="time">2019-03-09</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">除了内存模型外，其他的都简单易懂。所以内存模型一定要放前面讲。</p>
                                <p class="reply-time">2019-03-09</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/0f/52/e4/c5d75f0f.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">Joanfen</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">老师好可爱啊，认真回复大家的留言，不吝夸奖👍在评论区也学到很多，跟大神们学习</div>
                            <span class="time">2019-03-09</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">这么晦涩的东西大家都耐着性子看完了，很不容易😄</p>
                                <p class="reply-time">2019-03-09</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="http://thirdwx.qlogo.cn/mmopen/vi_32/zZiamzXOang0L4iaXa37k1wM8TqU6cqkQNCKZ9XUBWXPFndtvkXrtRGMLPur4zIvoYMHaicIU1fFibKTZJo8Lmnxug/132" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">suynan</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">一直有个疑问，synchronized保证了只能有一个线程能进入临界区，这是结论。<br>但是在进入临界区前的竞争是怎么处理的？极端一点，假如2个线程AB在完全相同的时刻去竞争，那么会不会同时跨过那道门槛进入临界区？我们知道的结果是不能，只能有一个能进入，但是保证的手段是什么呢？unsafe?AQS?希望老师指点一下</div>
                            <span class="time">2019-03-08</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">这个一言难尽，推荐你看 java并发编程的艺术吧，里面有详细介绍<br></p>
                                <p class="reply-time">2019-03-08</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/10/21/20/1299e137.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">秋天</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">每次枷锁进来都是一个新的对象，加锁和解锁面对的不是同一个对象，所以对于可见性和原子性问题没有保障作用</div>
                            <span class="time">2019-03-08</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">正确</p>
                                <p class="reply-time">2019-03-08</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/11/2e/61/72a083ea.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">小公司都不给我进就赖门口哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">感觉评论区的大神很多鸭</div>
                            <span class="time">2019-03-08</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">我也这样觉得</p>
                                <p class="reply-time">2019-03-08</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/12/bc/eb/c22ef3a5.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">Nevermore</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">针对同一个资源，必须使用同一把锁，才能实现原子性和可见性，即保证并发正确性。</div>
                            <span class="time">2019-03-08</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">理论高手</p>
                                <p class="reply-time">2019-03-08</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/0f/76/23/31e5e984.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">空知</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">老师 Java内存模型包括synchronized关键字 不是说明Javanese内存模型可以解决原子性问题嘛？</div>
                            <span class="time">2019-03-07</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">你这么理解也可以，工程上很多概念都不是那么清晰，解决原子性需要用到hb原则<br></p>
                                <p class="reply-time">2019-03-08</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/11/fe/14/f1532dec.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">ooo</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">我用visualvm监控consumer线程栈，过一会两个consumer线程栈就消失了</div>
                            <span class="time">2019-03-06</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">那就是执行完了，正常退出了<br></p>
                                <p class="reply-time">2019-03-07</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/16/00/92/0d378734.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">HYH®侯博元</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">为什么双重判断的单例模式加了sncy还会有线程问题，而这期的案例加了sncy就不会有线程问题</div>
                            <span class="time">2019-03-06</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">重新看看第一期吧</p>
                                <p class="reply-time">2019-03-07</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/10/e4/e9/0dd3829f.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">aguan(^･ｪ･^)</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">思考题<br>不能解决可见性和原子性的问题，因为每次加锁时都new object，都是不同的对象，也就相当于每次请求都是不同的锁🔒，违背了文中说的锁跟资源的1对N关系。锁和资源的关系变成了N对1的关系</div>
                            <span class="time">2019-03-06</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">中规中矩</p>
                                <p class="reply-time">2019-03-06</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/0f/fd/8d/f66a0206.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">零</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">打卡第一天，以前系统学习了一次，没有很好的实战，很快就忘了，希望这次重新学习并应用于实际的项目。</div>
                            <span class="time">2019-03-06</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">坚持就有收货<br></p>
                                <p class="reply-time">2019-03-06</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/10/e7/7c/a8275e98.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">wilburjiang91</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">请问老师，临界区这个概念是来自操作系统吗？</div>
                            <span class="time">2019-03-06</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">我是从操作系统里知道的，一定比java早<br></p>
                                <p class="reply-time">2019-03-06</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/12/ae/af/985298a8.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">Michelle</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">應該在一開始先new object<br>Sychronized才不會一直new新的出來</div>
                            <span class="time">2019-03-06</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">是的</p>
                                <p class="reply-time">2019-03-06</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/11/ad/27/5556ae50.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">Demter</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">可见性和原子性都保证了，可是有序性为啥没有分析呢</div>
                            <span class="time">2019-03-06</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">有序性和可见性是一起解决的<br></p>
                                <p class="reply-time">2019-03-06</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/13/18/f6/2ff7bc7a.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">轻歌赋</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">锁不住的，锁对象不是同一个</div>
                            <span class="time">2019-03-06</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">每次调用的锁都不是一个</p>
                                <p class="reply-time">2019-03-06</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/11/fe/14/f1532dec.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">ooo</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">锁竞争会导致线程被kill吗？三个consumer线程，一个producer线程，运行一段时间后，有两个consumer线程挂掉了<br><br>public class Producer extends Thread {<br><br>    List&lt;Message&gt; msgList = new ArrayList&lt;&gt;();<br><br>    public Producer(){<br>        super("Producer1");<br>    }<br><br>    @Override public void run() {<br>        try {<br>            while (true) {<br>                Thread.sleep(3);<br>                Message msg = new Message();<br>                synchronized(msgList) {<br>                    msgList.add(msg);<br>                    msgList.notify(); //这里只能是notify而不能是notifyAll，否则remove(0)会报java.lang.IndexOutOfBoundsException: Index: 0, Size: 0<br>                }<br>            }<br>        } catch (Exception e) {<br>            e.printStackTrace();<br>        }<br>    }<br><br>    public Message waitMsg() {<br>        synchronized(msgList) {<br>            if(msgList.size() == 0) {<br>                try {<br>                    msgList.wait();<br>                } catch(InterruptedException e) {<br>                    e.printStackTrace();<br>                }<br>            }<br>            return msgList.remove(0);<br>        }<br>    }<br>}</div>
                            <span class="time">2019-03-06</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">挂掉是什么意思？锁竞争一定不会导致线程被kill</p>
                                <p class="reply-time">2019-03-06</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/0f/8d/99/f886543d.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">渔夫</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">不理解的是，加🔒就能保证读的时候会从内存读，而不从缓存读？</div>
                            <span class="time">2019-03-06</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">happens_before规则保证的，这个规则是jsr规范，虚拟机必须实现规范</p>
                                <p class="reply-time">2019-03-06</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/13/0d/ac/09678490.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">谢特</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">禁止cpu中断什么意思</div>
                            <span class="time">2019-03-06</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">cpu不响应中断信号<br></p>
                                <p class="reply-time">2019-03-06</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/13/36/d2/c7357723.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">发条橙子 。</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">首先说答案： <br><br>因为该同步块 锁 是每次new新对象 ，所以每个线程都拥有一个锁 ，所以不能达到互斥目的 。 <br><br>解决： <br><br>在该类下创建一个成员变量 object ， 使用该对象作为锁可达到互斥效果<br><br>问题 ： <br><br>老师， count++ 是因为多核情况下 ，有可能多个线程同时访问共享资源导致原子性问题 。 <br><br>那么在单核情况下 ， 就不存在多个线程同时访问共享资源 ，就不会有原子性问题了呢 。这时候发生线程切换 ， 比如 从执行添加线程 切换到 执行get线程 ，只是存在可见性问题 ， 这个时候给资源加上 voltaile 关键字是不是就可以解决并发问题了 ？<br><br>这是我的理解，希望老师解答 😝</div>
                            <span class="time">2019-03-05</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">单核也不能保证原子性<br>单核没有缓存问题，有原子性问题。两个线程可以先后读到寄存器，这个时候还没有写，基于这个做＋法，就会出现前一个的写被后一个线程覆盖的问题<br><br></p>
                                <p class="reply-time">2019-03-06</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">jmdxy</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">get方法加锁是为了确保读取long类型数据的时候 ，没有其他线程修改long类型数据的操作。 老师这样理解对吗？</div>
                            <span class="time">2019-03-05</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">对，就是为了互斥</p>
                                <p class="reply-time">2019-03-05</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/12/61/94/713b38ef.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">小和尚笨南北</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">这个相当于给门上加了一把锁，但是所有的钥匙都可以打开，也就等于没加锁。</div>
                            <span class="time">2019-03-05</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">生动</p>
                                <p class="reply-time">2019-03-05</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">Geek_43d4ff</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">getOne和addOne每次加锁在不同资源上，因为new,所以加锁不在同一个对象上，并没有形成互斥。</div>
                            <span class="time">2019-03-05</span>
                            
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/13/1b/0d/9c3e2241.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">常银玲</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">老师您好，最后总结中说，锁一定要有一个锁定的对象，当new object的时候，就换了一个上锁的对象，锁住的不是同一个资源，所以没有办法保证资源的同步。其实应该去思考：为什么synchronized锁的是一个对象，而不是一个类，是不是和Java本身的设计有什么关系？</div>
                            <span class="time">2019-03-05</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">没思考过，我觉得锁，本来就该是个对象</p>
                                <p class="reply-time">2019-03-05</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/10/c7/ba/4490a37f.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">zhaozp</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">new 创建了不同的对象</div>
                            <span class="time">2019-03-05</span>
                            
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/16/0e/0a/1564a5e1.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">忠艾一生</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">这样并不能解决并发问题，相当于两把不同的锁来保护同一个资源了。</div>
                            <span class="time">2019-03-05</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">是很多锁</p>
                                <p class="reply-time">2019-03-05</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erS45sT36oSCibh8YMF9aD0IKltrdCoEicqUeEzbC2Hlr4UiahibfLvpib3LauzQxv6X3vyfCvrgz0m3dg/132" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">jeeker</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">王老师,问个问题:<br>保护资源的时候是不是只要同一把锁就好了,而不是说必须得某一把锁是吗?<br>举个例子, 两个对象 A.class ,B.class 是不是可以这样操作<br>class A {<br> static int a ;<br> synchronized(B.class) static void add (){<br>     a+=1;<br>    }<br>} <br>这种情况下多线程是不是也是互斥的?</div>
                            <span class="time">2019-03-05</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">是的，只要一把锁就行。但是工程上，这样容易出问题。因为这个锁是JVM全局唯一的。有可能别人也用这个</p>
                                <p class="reply-time">2019-03-05</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/10/b4/95/433d47eb.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">Geek_ed5c7b</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">关于可见性有点疑问，希望老师可以解答下。<br>在多核CPU中，例如两个线程同时将一个变量读入主存（volatile a=3）。当一个线程将a修改成4了，但是还没有来得急将其刷新至内存。这样对于另外一个线程来说这个a是不可见的吧？是不是哪怕用volatile修饰了变量也无法保证100%可见？</div>
                            <span class="time">2019-03-05</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">volatile规则是说 写》读。其他的不保证。写完后读一定能读到。但是你同时读，谁也搞不定。这个要靠互斥搞定。<br></p>
                                <p class="reply-time">2019-03-05</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/15/fb/f5/6521cb02.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">李可威</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">大佬们Lock锁和synchronized有什么区别？另外可重入锁、可中断锁、公平锁都是什么意思</div>
                            <span class="time">2019-03-05</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">别急</p>
                                <p class="reply-time">2019-03-05</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/10/f9/aa/98d9c41c.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">龙猫</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">不可以，不是互斥锁</div>
                            <span class="time">2019-03-05</span>
                            
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/0f/54/44/4e541a86.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">Junzi</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">new Object()使每次线程访问该对象方法都会生成一个新的锁，即每次的锁都不一样，不能保证原子性和可见性</div>
                            <span class="time">2019-03-05</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">YES</p>
                                <p class="reply-time">2019-03-05</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/0f/52/3c/0c71ad7e.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">张三</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">很有收获，相同的锁才互斥，并不是随意加一个锁就行了。</div>
                            <span class="time">2019-03-05</span>
                            
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/15/ff/c6/8b5cbe97.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">刘志兵</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">老实，静态方法锁住的对象是静态类对象，那如果静态方法中有多个静态方法，给其中一个加上synchronize而且被一个线程锁住的话，是不是其他线程执行其他方法也不行</div>
                            <span class="time">2019-03-05</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">不行！</p>
                                <p class="reply-time">2019-03-05</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/10/99/c9/a7c77746.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">冰激凌的眼泪</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">锁value是否有效果？</div>
                            <span class="time">2019-03-05</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">后面的章节还真问到这个问题了</p>
                                <p class="reply-time">2019-03-05</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/10/86/3a/76dbbd0e.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">空空空空</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">回答问题： 我觉得这样解决不了并发问题。该题目中每次锁的对象都是new出来的不同的对象，相当于每个线程获得的锁都是不一样的，并不会互斥。老师这样理解正确吗</div>
                            <span class="time">2019-03-05</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">正确。</p>
                                <p class="reply-time">2019-03-05</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/10/22/46/dfcdc05e.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">DebugCat</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">每个线程每次执行这两个方法时，每次都是对不同的对象（每次重新new）加锁（对象头中写入锁状态），并没有形成互斥锁。这样其实每次调用不同线程均可进入，无法保证可见性和原子性。</div>
                            <span class="time">2019-03-05</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">正确</p>
                                <p class="reply-time">2019-03-05</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">影子传说</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">老师上面用java内置锁保证count++操作能用volatile代替吗？volatile可以保证多线程可见，在结合happen before规则似乎也可以的。请老师指导下</div>
                            <span class="time">2019-03-05</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">不可以。<br>两个线程可以同时读到同一个值（这个违背任何HB），然后同时+=1，写入内存（这个违背任何HB）。结果是少加了一个1</p>
                                <p class="reply-time">2019-03-05</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/11/2b/45/e8f64725.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">Smile</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">互斥性关注两个点：<br>  1. 锁是什么对象<br>  2. 锁住的内存是什么，临界区的内容<br>同一个锁只能一个线程占有，当一个线程抢占到锁时，其他线程只能等到释放后才可以抢到。<br>对于思考题，由于不是同一个锁，而且是每个线程创建一次，不存在锁的竞争，所以原子性不能保证。共享变量在多线程存在可见性问题，对一个锁解锁 Happens-Before 后续对这个锁的加锁，不是同一个锁，无法解决共享变量value的可见性问题，请老师，评判指正☺</div>
                            <span class="time">2019-03-05</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">分析的很到位了！</p>
                                <p class="reply-time">2019-03-05</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/13/ce/f6/49bff405.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">TaroYoVen</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">不同锁，所以并没有互斥</div>
                            <span class="time">2019-03-05</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">而且每次调用都不同</p>
                                <p class="reply-time">2019-03-05</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/10/79/69/5960a2af.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">王智</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">不能，可以new一个object当做成员变量，应该就可以了。</div>
                            <span class="time">2019-03-05</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">正确<br></p>
                                <p class="reply-time">2019-03-05</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/13/16/97/9e342700.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">&nbsp;JJ</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">老师，受保护资源和锁的关系是1:N吧</div>
                            <span class="time">2019-03-05</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">你比我说的还抽象</p>
                                <p class="reply-time">2019-03-05</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/10/78/c7/083a3a0b.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">新世界</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">对于get方法不加synchronized关键字会出现并发问题的场景，可以这样理解吗？CPU a加锁设置count值为1，同时从寄存器同步值1到主存，CPU b这时候执行get方法没有加同一把锁，不会从主存拿最新值更新到CPU b的寄存器，当CPU b执行get方法时，依然获取的时之前cpu b寄存器的值，不是主存中更新的最新值，可以这样理解吗？</div>
                            <span class="time">2019-03-05</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">你可以这样理解。</p>
                                <p class="reply-time">2019-03-05</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/16/00/f2/66a1461d.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">Solitary_J</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">两把锁不可见性</div>
                            <span class="time">2019-03-05</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">不仅仅是不可见</p>
                                <p class="reply-time">2019-03-05</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/11/19/a3/600bc13d.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">无庸</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">这个例子value 加 volatile 修饰之后。根据happen before 原则写之后，读也是可见的吧</div>
                            <span class="time">2019-03-05</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">可见。不保证原子性</p>
                                <p class="reply-time">2019-03-05</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/14/06/62/898449d3.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">... ...</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">加加操作原子性没问题！可见性没有'</div>
                            <span class="time">2019-03-05</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">原子性也有问题，因为相当于无锁</p>
                                <p class="reply-time">2019-03-05</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/11/02/e3/2a624978.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">Thomas</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">加锁的对象不同</div>
                            <span class="time">2019-03-05</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">不仅仅不同</p>
                                <p class="reply-time">2019-03-05</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/10/1d/13/31ea1b0b.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">峰</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">每次进入临界区，拿的锁都不一样，这和不加锁的代码是一样的，就是慢好多😄</div>
                            <span class="time">2019-03-05</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">应该不会慢，编译器会优化成无锁代码</p>
                                <p class="reply-time">2019-03-05</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/12/48/2d/7a3d42fb.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">Alan</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">首先回答下课后问题哈，使用方式是不正确的，每次都锁资源都是不一样的，导致等于没加锁，不能保证可见性。</div>
                            <span class="time">2019-03-05</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">👍厉害<br></p>
                                <p class="reply-time">2019-03-05</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/12/bc/eb/c22ef3a5.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">Nevermore</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">一个资源，使用了两把锁。</div>
                            <span class="time">2019-03-05</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">每次调用都创建了新的，相当于无锁，编译器会优化掉同步关键字<br></p>
                                <p class="reply-time">2019-03-05</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJUzv6S9wroydkGP6m3OsQ8QuI4jAibv21tNkm7KVGPffJibj8Y29yIdKl4qkDGd3iaGJCSGVarfxoibQ/132" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">狂战俄洛伊</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">嗯，有问题，两把锁锁的资源不一样，这两把锁并不是互斥的，所以存在并发问题😁</div>
                            <span class="time">2019-03-05</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">👍<br></p>
                                <p class="reply-time">2019-03-05</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/13/f5/98/477a2da0.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">小小小丶盘子</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">思考题中，每次访问都会加锁，但是每次锁不同(new object），老师在文中提到，一把锁可以对应N个资源，现在是多把锁对应一个资源，并不能起到互斥作用，加1操作并不是原子性。同时由于不是一把锁，可见性也无法实现。不符合Happen before 原则。我的个人理解，请老师批评指正。😄</div>
                            <span class="time">2019-03-05</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">是这样，没有任何互斥作用<br></p>
                                <p class="reply-time">2019-03-05</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLRwauvbuyKfib8Qm3NBNU908zhKS0WPnvTEN4EJYSJyKwMuSHTWgXqP5WrSexgQAhLSiblydA24EMg/132" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">笨拙的自由</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">不正确，两个方法不是竞争同一把锁，对资源起不了保护作用</div>
                            <span class="time">2019-03-05</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">👍<br></p>
                                <p class="reply-time">2019-03-05</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/10/64/86/6b593cb9.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">Zach_</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">① class SafeCalc {<br>  long value = 0L;<br>  long get() {<br>    return value;<br>  }<br>  synchronized void addOne() {<br>    value += 1;<br>  }<br>}<br><br>多线程下 addOne() 原子可见均没问题 <br>多线程下 get() 可见性有问题 不遵循happens–before原则<br><br>② class SafeCalc {<br>  long value = 0L;<br>  long synchronized get() {<br>    return value;<br>  }<br>  synchronized void addOne() {<br>    value += 1;<br>  }<br>}<br><br>多线程下 get addOne 的 原子性 可见性都没问题 遵循happens–before原则<br><br>③ class SafeCalc {<br>  long value = 0L;<br> synchronized  long get() {<br>    return value;<br>  }<br>  synchronized void static addOne() {<br>    value += 1;<br>  }<br>}<br><br>多线程下 get addOne 都有问题 所对象不同<br><br><br>④ class SafeCalc {<br>  long value = 0L;<br>  long get() {<br>    synchronized (new Object()) {<br>      return value;<br>    }<br>  }<br>  void addOne() {<br>    synchronized (new Object()) {<br>      value += 1;<br>    }<br>  }<br>}<br><br> 这两个 new Object()，不是同一个锁对象，也就不满足happens–before原则对同一锁对象的要求，因此可见性和原子性都不能保证啦！<br><br>每次锁的对象不一样，任意一个线程都可以进来，都可能读到相同的值，就像读到都是0，然后又同时写了两次1一样，所以不是线程安全的啦!<br><br>有说不对的地方老师告知一下啊！</div>
                            <span class="time">2019-03-05</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">完全正确<br></p>
                                <p class="reply-time">2019-03-05</p></div>
                        </div>
                    </li><li data-v-87ffcada="" class="comment-item">
                        <img src="https://static001.geekbang.org/account/avatar/00/12/8a/5a/b67a82e3.jpg" class="avatar">
                        <div class="info">
                            <div class="hd"><span class="username">shen</span>
                                <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span class="like-count">0</span></a></div>
                            </div>
                            <div class="bd comment-content">题目中new Object() jvm会自动优化点的，所以他是无效的，可以声明一个成员变量Object lock=new Object()，使用lock这个锁</div>
                            <span class="time">2019-03-05</span>
                            <div class="reply">
                                <div class="reply-hd"><i class="iconfont"></i> <span class="reply-username">作者回复</span></div>
                                <p class="reply-content">👍厉害<br></p>
                                <p class="reply-time">2019-03-05</p></div>
                        </div>
                    </li></ul>
            </div>
        </div> <!----> <!----></div>
</div>
<link rel="dns-prefetch" href="//cdn.mathjax.org">
<script type="text/x-mathjax-config">MathJax.Hub.Config({
        showProcessingMessages: false,
        messageStyle: "none",
        tex2jax: {
          inlineMath: [['$','$'], ['\\(','\\)']],
          displayMath: [ ["$$","$$"] ],
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code', 'a']
        }
      });
      MathJax.Hub.Register.MessageHook("End Process", function (message) {
        var eve = new Event('mathjaxfini')
        window.dispatchEvent(eve)
      })




</script>

</body>